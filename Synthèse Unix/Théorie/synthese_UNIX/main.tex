\documentclass{article}[12pt]

%--------------Packages------------------------------
\usepackage[utf8]{inputenc} %Pour encoder du texte en français
\usepackage[francais]{babel} %Pour encoder du texte en français
\usepackage{graphicx} %pour inclure des images
\usepackage{changepage}
\usepackage{version} % permet d'utiliser l'environnement comment
\graphicspath{{./figures/}} %repertoire images
\usepackage{listings} %si on veut afficher du code, le code doit se trouver dans un dossier "codes" 					  %lui même dans le même répertoire que ce fichier tex
\usepackage{color} %nécessaire pour changer les couleurs du highlighting du code
\usepackage{amsmath,amssymb}%pour des maths au cas où
\usepackage{array,multirow,makecell}%Pour manipuler les tableaux
\usepackage{url} %pour utiliser les liens hypertextes
\usepackage{hyperref} %pour utiliser les liens hypertextes
\usepackage{float}
\newlength{\offsetpage}
\setlength{\offsetpage}{2.0cm}
\newenvironment{widepage}{\begin{adjustwidth}{-\offsetpage}{-\offsetpage}%
    \addtolength{\textwidth}{2\offsetpage}}%
{\end{adjustwidth}}

\newcommand{\Java}[2]{
	\begin{itemize}
    	\item[]\lstinputlisting[caption=#2,label=#1]{#1.java}
	\end{itemize}
}
% ---------- Document ------------ %
\begin{document}

\input{page_de_garde.tex}

\tableofcontents%table des matières
\newpage
\section{Introduction}
Interfaces du noyau, ils sont écrit et utilisés en C (Ils peuvent également être utilisé dans d'autres langages). Il y en a un nombre finis dans le noyau Unix. (Le point d'entrée du noyau est unique, chaque appel système est un des branchements de ce switch). Il en exite différents types :
\begin{itemize}
	\item IO
    \item File management
    \item Protection
    \item Processes
    \item Misc
\end{itemize}
\paragraph{Problèmes de portabilité : } Les programmes utilisant directement les appels systèmes ne sont pas des standard du langage C, sont des programmes C "Unix", ne sont pas portable entre les différents types de Unix. (Problème avec les appels systèmes : les fichiers en-têtes, ainsi que le type des arguments). Afin d'éviter ce genre de soucis, utiliser une directive de compilation (CPP).
\paragraph{Types de données des primitives sytèmes : } (permet de cacher les détails d'implémentation, définit au sein de <sys/types.h>)
\paragraph{Traitement des erreurs :} tous les appels systèmes retournent -1 en cas d'erreur. De ce fait le code de retour d'un appel système doit toujours être vérifié. (On peut également utiliser errno (<errno.h>) ainsi que perror
\paragraph{Opérations I/O : } Unix fournit une interface uniforme sur des ressources telles que :
\begin{itemize}
	\item Fichiers
	\item Terminaux
	\item Pipes
	\item "Tapes"
	\item "Network Sockets"
\end{itemize}
Les ressources sont identifiées par un entier appelé "file descriptor" (il s'agit d'une abstraction du programme afin d'accéder à une ressource). Il faut également savoir que les appels systèmes ne peuvent pas être bufferisées (Chaque appel système implique une opération au niveau du noyau ainsi qu'au niveau de l'appareil).
\section{File Descriptor}
Les fichiers ouverts sont désignés par un "file descriptor". Ils sont obtenus à l'aide des opérations open(), creat(), socket(). Pour chaque processus le noyau maintient une table des fichiers ouverts. Il existe trois "file descriptor" réservés au système : 
\begin{itemize}
	\item \emph{0} : Entrée Standard
	\item \emph{1} : Sortie Standard
	\item \emph{2} : Sortie d'erreur
\end{itemize}
\paragraph{Les fichiers : }
Les fichiers sont vus comme des séquences de bytes (pas d'enregistrement, les blocs physiques ne sont pas visibles). L'offset du fichier courant "tight" au "file descriptor". Les blocs d'appareils sont vus comme des séquences de blocs (l'entiereté des blocs sont lus/écrits en une fois).
\section{Standard I/O Library}
Interface uniforme permettant d'effectuer des opérations d'I/O (Il s'agit d'une interface efficace pour une programmation de haut niveau, fonctionnant avec les streams et permettant un système de buffer de haut niveau (Attention, les Appels Systèmes coûte très cher)) de manière très simple (un seul fichier à inclure (\#include <stdio.h>)).
\paragraph{Les Streams : }
Similaire au "file descriptor", ils désignent les appareils (Ils existent bien entendus des streams prédéfinis de base (stdin, stdout, stderr), et ils sont alloués dynamiquement(un appel à malloc n'est pas requis, la fonction fopen s'en chargeant pour nous)).
\paragraph{User-level buffering : } la sortie n'est pas synchronisée (afin de pallier à cela on pourrait utiliser le système de "flush" (fflush, setbuf)). De plus les streams peuvant être détruit à l'aide de fclose().
\paragraph{Fonctions d'entrée}
\begin{itemize}
	\item int fgetc(FILE *stream);
	\item char *fgets(char *s, int size, FILE *stream);
	\item int getc(FILE *stream);
	\item int getchar(void);
	\item char *gets(char *s);
	\item int ungetc(int c, FILE *stream);
	\item scanf(char * format, ptr1, ptr2);
	\item fscanf(FILE * ioptr, char * format, ptr1, ptr2);
	\item sscanf(char * inbuf, char * format, \&arg1, \&arg2);
	\item strtok 
\end{itemize}   
Attention à un eventuel buffer overflow (il faut toujours vérifier la taille de ce que l'on reçoit, gets est d'ailleurs à éviter).
\paragraph{Fonctions de sortie}
\begin{itemize}
	\item int fputc(int c, FILE *stream);
	\item int fputs(const char *s, FILE *stream);
	\item int putc(int c, FILE *stream);
	\item int putchar(int c);
	\item int puts(const char *s);
	\item printf(char * format, arg1, arg2);
	\item fprintf(FILE * ioptr, char * format, arg1, arg2);
	\item sprintf(char * outbuf, char * format, arg1, arg2); 
\end{itemize}
\paragraph{Les bonnes pratiques de programmation : } il vaut mieux utiliser fgets afin de lire les lignes entrées. Il faut vérifier si un input est vide. Il vaut mieux utiliser sscanf afin de décoder les lignes entrées. Il faut utiliser strtok afin de recevoir un token à partir d'un input.
\section{Redirection}
\paragraph{Limite des Ressources} Les ressources peuvent être limitées au niveau du shell (ulimit -aS pour une "soft limit" et ulimit -aH pour une "hard limit").
\paragraph{User kernel ops "mapping" :} pour chaque commande/operation au niveau de l'utilisateur il y en a un équivalent au niveau du noyau.
\paragraph{Implémenter une redirection :} fermer l'entrée/sortie standard ouvrir un fichier d'entrée/sortie (open() renvoie le plus petit "file descriptor" disponible). Il fqut faire attention car certains problèmes peuvent survenir (l'appareil originel pointé par fd=0 est fermé, par la suite fd=0 est remplacé par "in", le fichier originel perdus est le clavier), la solution à cela est d'utiliser int dup(int fd) qui permet une dupplication du "file descriptor".
\paragraph{Mécanismes d'entrées/sorties : } 
\begin{itemize}
	\item \emph{Mécanismes d'entrées/sorties basiques UNIX : } les données sont lues/écrites depuis les fichiers par un processus. Les i/o sont vus commes des séquences de bytes non-structurées.
	\item \emph{Mécanismes d'entrées/sorties mappés en mémoire : } les objets externes sont mappés dans la mémoire virtuelle du processus.
\end{itemize} 
\section{Locks}
creat() et unlink() peuvent être utilisés afin de créer des cadenas (Locks) (while (creat("lockfile", 0) < 0) sleep(); unlink("lockfile")). Il faut faire attention car cela peut générer une erreur (le orphan lockfile). Il faut savoir que de nombreux problèmes apparaissent lorsque de multiples processus accèdent à la même donnée simultanément. (Pour cela on peut protéger les données à l'aide de cadenas, ces cadenas peuvent être implémentés de bien des manières mais ils doivent être atomiques et sont conseillé et non obligatoire).
\section{Processus}
Un processus est un programme en cours d'exécution. (Un programme est donc un objet statique (un exécutable dans le système de fichier), le processus quant à lui est un objet dynamique (il changera durant l'exécution)).
\paragraph{Définition d'un processus : } Un processus est un programme en cours d'exécution. Un processus contient des données en mémoire dont :
\begin{itemize}
	\item \emph{Du texte : } les instructions qui devront être exécutées.
	\item \emph{Des données globales : } initialisées ou non.
	\item \emph{Des données locales : } placées sur la pile.
	\item \emph{Un Heap : } de la mémoire libre pour les appels à la fonction malloc.
	\item \emph{Un environnement d'exécution :} tant pour le programme (statut, ...) que pour le système.
	\item \emph{Des variables d'environements : } Il s'agit de couples de clé-valeur qui peuvent être accédées par le processus tout comme par ses enfants.
\end{itemize}
Il est identifié par un numéro unique dans le système Unix (PID : process identifier). Il est exécuté par un utilisateur (UID : Identifie l'utilisateur exécutant le processus). 
\paragraph{Les variables d'environnement : } Un processus garde ses variables d'environnement et les paramètres de l'utilisateur définissent des variables d'environnement. Il s'agit de couple clé-valeur. On peut y accéder à partir d'un programme utilisateur (getenv()).
\paragraph{Lancer un processus : } La seule manière de créer un processus est de le faire à l'intérieur d'un processus existant et en utilisant l'appel système fork().
\section{Interruptions système}
Un signal électrique est envoyé par un appareil au processeur afin de stopper l'exécution du processus courant et de faire quelque chose de différent. Le gestionnaire d'interruption est sélectionné par le processeur par la lecture du vecteur d'interruption récupéré de l'appareil. L'état d'exécution est sauvegardé avant l'exécution du gestionnaire d'interruptions et restauré par la suite.
\paragraph{Les signaux : } il s'agit d'interruptions software. Les signaux peuvent être envoyés à un processus par un autre processus, par le terminal de controle, par lui-même ou tout simplement par le système. L'action par défaut d'un signal est de terminer le processus  et de produire un fichier "core dump" (dépend du type de signal). Un processus peut décider d'ignorer certains signaux ou d'en attraper certains. Un signal peut être envoyé à un groupe de processus (Mais un signal ne peut être envoyé que par un processus ayant le même uid). Liste des signaux : 
\begin{itemize}
	\item SIGHUP : Hangup/Reload (Terminate)
	\item SIGINT : Keyboard interrupt (Terminate)
	\item SIGILL : Illegal Instruction (Core dumped)
	\item SIGFPE : Arithmetic exception (Core Dumped)
	\item SIGKILL : Kill (Terminate)	
	\item SIGBUS : Bus error (Core Dumped)
	\item SIGSEGV : Segmentation Violation (Core Dumped)
	\item SIGPIPE : Write a pipe (no reader) (Terminate)
	\item SIGALRM : Alarm clock (Terminate)
	\item SIGTERM : Software termination (Terminate)
	\item SIGSTOP : Stop (Suspended)
	\item SIGTSTP : Stop (from keyboard) (Suspended)
	\item SIGCONT : Continue after stop (Discarded)
	\item SIGCHLD : Child status has changed (Discarded)
	\item SIGUSR1 : User defined signal 1 (Terminate)
	\item SIGUSR2 : User defined signal 2 (Terminate) 
\end{itemize}
Les signaux peuvent être générés par le clavier. Les signaux ne sont traités que si le processus est actif, est en attente I/O sur un appareil plutot lent, ou sur un pipe. D'ailleurs si le signal arrive lors d'une attente I/O cette attente d'I/O se termine prématurément.
\section{IPC's}
\paragraph{Introduction : } Il existe différents types de structure IPC (Les files de messages, les sémaphores, les mémoires partagées). Mais ils partagent tous des caractéristiques communes : un identifiant d'IPC ainsi qu'une structure de permission.
\paragraph{Identifiant IPC : } L'identifiant IPC permet d'identifier la structure IPC. IL s'agit d'un entier ne pouvant que s'incrémenter. Il est renvoyé par int msgget(key\_t key, int msgflg); (pour les files de messages), int semget(key\_t key, int nsems, int semflg); (pour les sémaphores) ainsi que int shmget(key\_t key, size\_t size, int shmflg); (pour les mémoires partagées). Les clés permettent d'accepter de nouveaux processus sur de telles structure. Les identifiant IPC sont globaux dans le système UNIX.\\ \\
La clé peut prendre comme valeur : IPC\_CREAT (si la clé est disponible, crée l'objet IPC) ou IPL\_EXCL  (Si la clé est déjà utilisée, génère une erreur). Les structures IPC sont des structures largement répandues et peuvent être utilisées par des processus totalement différents. Le seul soucis est qu'il faut se mettre d'accord au sujet de tels fichiers (Une clé commune au sein d'un fichier d'include, LE serveur pourrait passer la valeur e l'ipc à travers un fichier ou pourrait générer la clé par ftok(const char *pathname, int project\_id) ).
\paragraph{Structure de permission des structure IPC : } Chaque structure IPC possède une structure ipc\_perm qui lui est reliée.  Voici sa composition :
{ uid\_t uid; /* owner’s effective user id */ \newline
gid\_t gid; \newline
 uid\_t cuid; /* creator’s effective used id */ \newline
 gid\_t cgid; \newline
 mode\_t mode; /* access mode */\newline
 ... \newline
 key\_t key; } 
 \newline
 Comme vous pouvez le remarquer, la composition de structure IPC est très similaire à celle représentant les droits d'accès sur les fichiers régulier. Celle ci peut être changée par : msgctl(), shmctl(), srmctl().
\section{Message queue}
Il s'agit d'une liste chaînée de message sauvegardée dans l'espace noyau.La pile est identifiée par a "message queue id". Elle est ouverte ou créée par msgget(). Les messages sont envoyés par msgsend() (Ils sont rajouté à la fin de la pile). Les messages sont lus par msgrcv() (Ils ne sont pas nécessairement lu en FIFO).  Ces piles possède une structure  msqid\_ds. Ils permettent une communication bidirectionelle entre des processus totalement différents. Les messages ont un type et les frontières entre ces derniers sont préservés. Les piles de message sont en dehors du système de fichier et en dehors de l'arborescence de processus).  
\section{Appels Systèmes}
\subsection{Open()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <stat.h>
	\item \#include <fcntl.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int open(const char \* path, int flags, mode\_t mode);
	\item int open(const char \* path, int flags);
\end{itemize}
\paragraph{Remarques : }
Ouvre les fichiers en écriture ou en lecture. Retourne soit le "file descriptor" soit -1 (en cas d'erreur). Le chemin, "Path", est une chaîne de cractères désignant la ressource dans le système de fichiers. Pour l'argument flags celui-ci peut prendre les valeurs de :
\begin{itemize}
	\item O\_RDONLY : ouvrir en lecture seulement.
	\item O\_WRONLY : ouvrir en écriture seulement.
	\item O\_RDWR : ouvrir en lecture et en écriture.
	\item O\_CREAT : crée le fichier si il n'existe pas.
	\item O\_APPEND : Place le pointeur sur EOF (permet d'écrire à la suite du contenu du fichier).
	\item O\_TRUNC : Si le fichier existe, le remplace.
	\item O\_EXCL : Crée le fichier d'erreur si il y en a.
\end{itemize}
Le mode est un argument utilisé avec O\_CREAT (Il s'agit du mode de fichier Unix). Les erreur quant à elles peuvent être spécifiées par errno.
\subsection{Creat}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <stat.h>
	\item \#include <fcntl.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int creat(const char \* path, mode\_t mode); Pour les fichiers
	\item int mkdir(const char \* path, mode\_t mode); Pour les dossiers
	\item int mknod(const char \* path, mode\_t mode, dev\_t dev); Pour les fichiers spéciaux
\end{itemize}
\subsection{Read()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item ssize\_t read(int fd, void \* buf, size\_t len);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{fd : } "file descriptor" du fichier dans lequel il faut lire. (Il peut s'agir d'un fichier "standard" tout comme un substitut d'un pipe ou d'un network socket).
	\item \emph{buf : } adresse du pointeur pour lequel l'input doit être copié.
	\item \emph{len : } Nombre maximum de bytes à lire.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } le nombre de bytes effectivement lus.
	\item \emph{0 : } La fin de fichier est atteinte.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Le retour peut (et est souvent) plus petit que la longueur attendue. Il faut donc être préparé à lire moins de données que ce qui était attendu. 
\subsection{Write}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item ssize\_t write(int fd, void \* buf, size\_t len);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{fd : } "file descriptor" du fichier dans lequel il faut écrire. (Il peut s'agir d'un fichier "standard" tout comme un substitut d'un pipe ou d'un network socket).
	\item \emph{buf : } adresse du pointeur pour lequel l'output doit être écrit.
	\item \emph{len : } Nombre maximum de bytes à écrire.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } le nombre de bytes effectivement lus.
	\item \emph{0 : } La fin de fichier est atteinte.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Le retour peut (et est souvent) plus petit que la longueur attendue. Il faut donc être préparé à lire moins de données que ce qui était attendu. 
\subsection{Lseek()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item off\_t lseek(int fd, int offset, off\_t whence);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{fd : } "file descriptor" du fichier ouvert. (Il peut s'agir d'un fichier "standard" tout comme un substitut d'un pipe ou d'un network socket).
	\item \emph{offset : } Nombre de bytes qui doivent être déplacés (évités) par le pointeur.
	\item \emph{whence : } point de départ (SEEK\_SET : début du fichier, SEEK\_CUR : à partir de la position courante, SEEK\_END à partir de la fin du fichier).
\end{itemize}
\subsection{Ioctl()}
Pour toutes les autres opérations I/O.
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/mtio.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int ioctl(int fd, MTIOCTOP, (struct mtop \*) mt\_cmd);
\end{itemize}
\subsection{Close()}
Permet de dissocier l'entier du descripteur de fichier. Il retourne 0 (en cas de succès) ou -1 (en cas d'erreur). Il faut savoir que tous les fichiers sont fermés lors de la fermeture du programme.
\subsection{Dup()}
\paragraph{Remarques : } int fd2 = dup(int fd1), fd2 est une dupplication de fd1. fd2 partage le même fichier d'entrée que fd1 (Par cela on entend que fd1 et fd2 partage les même drapeaux statut, le même mode d'accès tout comme le même offset du fichier courant). fd2 sera le plus petit "file descriptor" disponible. fd1 pourra être fermé, par contre l'appel à dup peut échouer (errno : EBADF, EMFILE).
\subsection{Dup2()}
Dup2() est une opération atomique permettant de regrouper close(fd2) ainsi que fd2 = dup(fd1).
\subsection{Mmap()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <sys/mman.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item caddr\_t mmap(caddr\_t addr, size\_t len, int prot, int fd, int off);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{addr : } devrait être 0.
	\item \emph{len : } Nombre de bytes à mettre en mémoire.
	\item \emph{prot : } Type d'accès(Peut être soit : PROT\_READ, PROT\_WRITE, PROT\_EXEC, PROT\_NONE).
	\item \emph{fd : } "File descriptor" à mettre en mémoire.
	\item \emph{off : } Origine de la map dans fd.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } Retourne le pointeur de base permettant d'accéder aux données.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Le fichier doit être ouvert, plusieurs processus peuvent mettre en mémoire le même fichier, mmap est utilisé par UNIX afin de partager les librairies.
\subsection{Munmap()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <sys/mman.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int munmap(caddr\_t addr, size\_t len);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{addr : } l'origine de la zone mémoire à enlever de la mémoire.
	\item \emph{len : } Nombre de bytes à enlever de la mémoire.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Détruit la mise en mémoire entre un fichier et l'espace adressé en mémoire virtuelle. Pour fermer un fichier, n'appeler surtout pas munmap. 
\subsection{Msync()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <sys/mman.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int msync(caddr\_t addr, size\_t len, int flags);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{addr : } l'origine de la zone mémoire à enlever de la mémoire.
	\item \emph{len : } Nombre de bytes à enlever de la mémoire.
	\item \emph{flags : } MS\_ASYNC (retourne immédiatement), MS\_INVALIDATE (permet d'invalider le "catching").
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Force le système à écrire les données mappées sur le disque.
\subsection{Link()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int link(const char \* name1, const char \* name2);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{name2 : } devient un autre nom pour l'objet déjà existant (name1). (Il s'agit donc juste d'un raccourci).
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Name1 et Name2 auront donc la même inode. (Il n'y a donc aucun moyen de savoir lequel des deux est le nom originel).
\subsection{Unlink()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int unlink(const char \* name);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{name : } sera supprimer du répertoire courant (si il s'agit de la dernière référence de l'objet, celui-ci sera également supprimé).
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
La permision en écriture est nécéssaire sur le répertoire parent. 
\subsection{Symlink()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int symlink(const char \* name1, const char \* name2);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{name2 : } sera un lien symbolique de l'objet référencé par name1.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Similaire au lien physiques sans les limitations des frontières du sytème de fichier.
\subsection{Readlink()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int readlink(const char \* path, void \* buf, size\_t bufsize);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{buf : } où mettre le résultat.
	\item \emph{bufsize : } la taille du buffer.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } la longueur utilisée du buffer. 
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Lit la valeur d'un lien symbolique.
\subsection{Stat()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <sys/stat.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int stat(const char \* path, struct stat \* buf); retourne des informations au sujet d'un fichier.
	\item int lstat(const char \* path, struct stat \* buf); retourne des informations au sujet du lien symbolique lui même.
	\item int fstat(int fd, struct stat \* buf); => retourne des informations au sujet de l'objet pointé par le lien symbolique. 
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{buf : } pointeur vers une structure de type stat.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } les informations au sujet de l'objet spécifié. 
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\subsection{Rename()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <stdio.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int rename(const char \* old, const char \* new);
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } la longueur utilisée du buffer. 
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Permet de remplacer l'ancien nom de fichier par le nouveau.
\subsection{flock()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/files.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int flock(int fd, int operation);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{operation : } peut prendre les valeurs : (LOCK\_SH qui signifie cadenas partagé (peut être utilisé par plus d'un processus), LOCK\_EX qui signifie cadenas exclusif (peut être utilisé par un seul processus), LOCK\_NB qui signifie que l'on ne doit pas bloqué lorsque le cadenas est pris (retournera -1 dans le cas où les fichier est bloqué) et LOCK\_UN qui permet de délocker une ressource. 
\end{itemize}
\subsection{Lockf()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int lockf(int fd, int cmd, off\_t len);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{fd : } "file descriptor".
	\item \emph{cmd : } peut prendre les valeurs : F\_LOCK (permet de placer le cadenas), F\_TLOCK (permet de placer le cadenas et de retourner 0 ou -1), F\_ULOCK (permet de nettoyer le cadenas, de le remettre à zéro) et F\_TEST (permet de tester le cadenas).
	\item \emph{len :} longueur de la zone à placer sous cadenas.
\end{itemize}
\subsection{Fork()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
    \item \#include <unsistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item pid\_t fork(void);
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } le pid du fils dans le processus père.
	\item \emph{0 : } au sein du fils.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Les deux processus ont les mêmes copies des données mémoires.De ce fait, ils partagent le même code, les même valeurs de variables, les mêmes fichiers ouverts, les mêmes pointeurs et les mêmes "file descriptor", le même répertoire de travail ainsi que le même terminal de controle. Mais ils ne partagent pas leur compteur de temps d'exécution, les valeurs des sémaphores, les cadenas sur les fichiers, ainsi que les signaux d'alarmes.
\paragraph{Cas spéciaux du fork : }
\begin{itemize}
\item \emph{Le processus parent termine avant le processus enfant :} l'enfant est dès lors attaché au processus init.
\item \emph{L'enfant termine avant le parent :} l'enfant devient dès lors un processus zombie (Il faut savoir qu'un processus enfant terminé continue d'exister tant que le parent ne se termine pas ou que le parent ne vérifie pas la valeur d'exit du processus enfant (wait(), ..)). Un processus zombie ne consume aucune ressource (à part peut être une entrée dans la table des processus).
\item \emph{Synchronisation :} Un processus parent doit parfois attendre que l'un de ses fils se termine. (Utilisation des appels systèmes wait() et exit()).
\end{itemize}
\subsection{Wait()}
Attend que l'un de ses fils se termine.
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
    \item \#include <sys/wait.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item pid\_t wait(int \* status);
    \item pid\_t waitpid(pid\_t pid, int \* status);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{status : } peut contenir des valeurs d'exit (lire le man).
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } le pid du fils que l'on attendait.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Il peut attendre un fils spécifique et même en attendre plusieurs.
\subsection{Exit()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int exit();
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
L'appel système \_exit(status) : Termine le processus courant immédiatement (les "file descriptor" ouverts sont fermés, les processus enfant sont envoyés à un autre processus (init), le processus parent recoit un signal SIGCHLD, le statut est retourné au processus parent).
La fonction exit(status) : exécute les fonctions de fin de processus (tels que le flushing des streams) et appelle \_exit(status).
Dès lors la fonction exit devrait être privilégiée à l'appel système \_exit().
\subsection{Exec()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int execl(const char \* pahtname, const char \* arg0, ... \/\* (char \*) 0 \*\/ ); le PATHNAME doit être exact.
    \item int execv(const char \* pathname, const char \* argv[]); Le PATHNAME doit être exact. 
    \item int execle(const char \* pathname, const char \* arg0, ... \/\* (char \*) 0, const char \* envp[] \*\/);
    \item int execve(const char \* pathname, const char \* argv[], const char \* envp[]); Il s'aggit du seul appel système.
    \item int execlp(const char \* filename, const char \* arg0, \/\* (char \*) 0 \*\/); On recherche le PATHNAME dans PATH.
    \item int execvp(const char \* filename, const char \* argv[]); On recherche le PATHNAME dans PATH.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Il exécute un processus, il ne le démarre pas (Le processus est déjà lancé par fork()) exec va dépasser le processus courant par un nouveau. Il s'agit d'une famille de fonctions mais d'un appel système. 
\subsection{Pipe()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int pipe(int filedes[2]);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{filedes[0] : } "file descriptor" ouvert pour lecture.
    \item \emph{filedes[1] : } "file descriptor" ouvert pour écriture.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Errno :}
\begin{itemize}
	\item EMFILE
    \item ENFILE
    \item EFAULT
\end{itemize}
\paragraph{Remarques : }
Plutot inutile au sein d'un seul processus. Il faut le combiner avec fork pour le rendre vraiment efficace. Les données vont dans une direction, les pipes ne peuvent être utilisées que dans des processus ayant au moins un ancêtre commun. (Il faut les paramétrer avant le fork). La synchronisation est possible par : le blocage du reader lorsque le pipe est vide, le blocage du writer lorsque le pipe est plein. Un processus pourrait être à la fois writer et reader. Les processus doivent par contre être d'accord sur la taille et le format des messages échangés. Les "file descriptor" qui ne sont pas utilisés doivent être fermés afin d'empêcher un deadlock d'apparaitre.
\paragraph{popen() : } permet de simplifier le processus d'envoi de données à un autre processus (Il faut inclure <stdio.h> et il se déclare : FILE \* popen(const char \* cmd, const char \* type);). Il s'utilise avec pclose(FILE \* stream). 
\subsection{Kill()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <signal.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int kill(int pid, int sig);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{pid : } processus de destination ou groupe du processus (pid > 0 le signal est envoyé au processus, pid = 0, le signal est envoyés à tous les processus du groupe de l'appellant, pid = -1 le signal est envoyé à tous les processus (à part init et les processus des autres utilisateurs), pid < -1 : le signal est envoyé à tous les processus du groupe du processus). On peut obtenir le pid à l'aide de fork (valeur de retour), getpid (retourne mon propre pid) ou getppid (retourne le pid du processus parent).
	\item \emph{sig : } le nom du signal ou son nombre (Si sig = 0 aucune action n'est effectuée). 
\end{itemize}
\paragraph{Errno :}
\begin{itemize}
	\item EINVAL : Le numéro de signal est invalide.
    \item ESRCH : Le pid n'existe pas.
    \item EPERM : La permission est refusée.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\subsection{Signal()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <signal.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item sighandler\_t signal(int signum, sighandler\_t handler);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{signum : } numéro du signal.
	\item \emph{handler : } Peut prendre les valeurs : SIG\_DFL (signal par défaut avec un gestionnaire par défaut), SIG\_IGN (permet d'ignorer le signal) ou tout simplement une valeur spécifiée par l'utilisateur.
\end{itemize}
\paragraph{Remarques : }
Queue : seulement un signal de chaque type peut être enregistré pour un processus (Si il y en a plusieurs, le processus n'en gère qu'un, les autres seront dès lors perdus). 
\begin{itemize}
	\item \emph{SYSV : } Lorsque le signal est traité, les gestionnaires sont remis à défaut.
    \item  \emph{BSD : } ne remet pas le gestionnaire à défaut mais bloque les signaux tant que le gestionnaire n'a pas finis son traitement (pas de défausse, mais mise en queue, ils seront juste remis par la suite). 
\end{itemize}
\paragraph{Vulnérabilité : } une fenêtre e vulnérabilité existe pour cela il faudra utiliser sigaction qui permet d'utiliser un masque durant le traitement du gestionnaire. Il utilisera le comportement BSD et bloquera les autres signaux durant le traitement du gestionnaire.
\subsection{Alarm()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item unsigned int alarm(unsigned int seconds);
\end{itemize}
\paragraph{Remarques : }
Envoie le signal SIGALRM après quelque secondes.
\subsection{msgget()}
\paragraph{Déclarations : }
\begin{itemize}
	\item int qid = msgget(KEY,mode|flags);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item flags peut prendre comme valeur soit : IPC\_CREATE (cela créera la structure si elle n'existait pas déjà et ouvrira la structure si celle ci existait déjà). soit IPC\_EXCL (crée la structure si elle n'existe pas et envoie une erreur ousinon).   
\end{itemize}
\subsection{msgsnd()}
\paragraph{Déclarations : }
\begin{itemize}
	\item int ret = msgsnd(int qid, const void *ptr, size\_t nbytes, int flag); 
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item qid : il s'agit de l'identifiant de la structure (l'id de la structure qid). 
\item ptr : un pointeur vers une structure contenant un long suivis des données du message.
\item nbytes: la taille de la zone de texte (doit être plus petit que MAX\_LENGTH).
\item flags peut prendre comme valeur IPC\_NOWAIT  
\end{itemize}
\subsection{msgrcv()}
\paragraph{Déclarations : }
\begin{itemize}
	\item int ret = msgrcv(int qid, void *ptr, size\_t nbytes, long type, int flag); 
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item qid : il s'agit de l'identifiant de la structure (l'id de la structure qid). 
\item ptr : un pointeur vers une structure contenant un long suivis des données du message.
\item nbytes: la taille du buffer (doit être égale à BUF\_MAX\_LENGTH). Le message pour sa part est censé être plus petit que BUF\_MAX\_LENGTH.
\item type : le type peut être égal à 0 (le premier message de la file est lu), au dessus de 0 (le premier message étant égal à type est lu) ou peut être en dessous de 0 (le premier message ayant un type plus petit ou égal à la valeur absolue de type est lu).
\item flags peut prendre comme valeur IPC\_NOWAIT (ne bloquera pas si la file est vide) ou MSG\_NOERROR (qui permet de tronquer les messages).
\end{itemize}
\subsection{msgctl()}
\paragraph{Déclarations : }
\begin{itemize}
	\item int msgctl(int qid, int cmd, struct msqid\_ds *ptr)  
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item qid : il s'agit de l'identifiant de la structure (l'id de la structure qid). 
\item ptr : un pointeur vers une structure IPC :  msqid\_ds.
\item cmd qui peut prendre comme valeur : IPC\_STAT (retourne la structure de controle), IPC\_SET (qui permet d'écrire : msg\_perm.uid, msg\_perm.gid, msg\_perm.mode et msg\_qbytes à la structure de contrôle) et IPC\_RMID (permet de supprimer la pile de message). 
\end{itemize}
\end{document}
