\documentclass{article}[12pt]

%--------------Packages------------------------------
\usepackage[utf8]{inputenc} %Pour encoder du texte en français
\usepackage[francais]{babel} %Pour encoder du texte en français
\usepackage{graphicx} %pour inclure des images
\usepackage{changepage}
\usepackage{version} % permet d'utiliser l'environnement comment
\graphicspath{{./figures/}} %repertoire images
\usepackage{listings} %si on veut afficher du code, le code doit se trouver dans un dossier "codes" 					  %lui même dans le même répertoire que ce fichier tex
\usepackage{color} %nécessaire pour changer les couleurs du highlighting du code
\usepackage{amsmath,amssymb}%pour des maths au cas où
\usepackage{array,multirow,makecell}%Pour manipuler les tableaux
\usepackage{url} %pour utiliser les liens hypertextes
\usepackage{hyperref} %pour utiliser les liens hypertextes
\usepackage{float}
\newlength{\offsetpage}
\setlength{\offsetpage}{2.0cm}
\newenvironment{widepage}{\begin{adjustwidth}{-\offsetpage}{-\offsetpage}%
    \addtolength{\textwidth}{2\offsetpage}}%
{\end{adjustwidth}}

\newcommand{\Java}[2]{
	\begin{itemize}
    	\item[]\lstinputlisting[caption=#2,label=#1]{#1.java}
	\end{itemize}
}
% ---------- Document ------------ %
\begin{document}

\input{page_de_garde.tex}

\tableofcontents%table des matières
\newpage
\section{Introduction}
Interfaces du noyau, ils sont écrit et utilisés en C (Ils peuvent également être utilisé dans d'autres langages). Il y en a un nombre finis dans le noyau Unix. (Le point d'entrée du noyau est unique, chaque appel système est un des branchements de ce switch). Il en exite différents types :
\begin{itemize}
	\item IO
    \item File management
    \item Protection
    \item Processes
    \item Misc
\end{itemize}
\paragraph{Problèmes de portabilité : } Les programmes utilisant directement les appels systèmes ne sont pas des standard du langage C, sont des programmes C "Unix", ne sont pas portable entre les différents types de Unix. (Problème avec les appels systèmes : les fichiers en-têtes, ainsi que le type des arguments). Afin d'éviter ce genre de soucis, utiliser une directive de compilation (CPP).
\paragraph{Compilation : } Il faut savoir que cc passe par plusieurs étapes de compilation (Pré processing (va s'occuper de traiter les define, les include, ...). Quant à gcc il faut faire attention car il s'agit d'un compilateur non optimisé.
\paragraph{Types de données des primitives sytèmes : } (permet de cacher les détails d'implémentation, définit au sein de <sys/types.h>)
\paragraph{Traitement des erreurs :} tous les appels systèmes retournent -1 en cas d'erreur. De ce fait le code de retour d'un appel système doit toujours être vérifié. (On peut également utiliser errno (<errno.h>) ainsi que perror.
\paragraph{Opérations I/O : } Unix fournit une interface uniforme sur des ressources telles que :
\begin{itemize}
	\item Fichiers
	\item Terminaux
	\item Pipes
	\item "Tapes"
	\item "Network Sockets"
\end{itemize}
Les ressources sont identifiées par un entier appelé "file descriptor" (il s'agit d'une abstraction du programme afin d'accéder à une ressource). Il faut également savoir que les appels systèmes ne peuvent pas être bufferisées (Chaque appel système implique une opération au niveau du noyau ainsi qu'au niveau de l'appareil).
\section{File Descriptor}
Les fichiers ouverts sont désignés par un "file descriptor". Ils sont obtenus à l'aide des opérations open(), creat(), socket(). Pour chaque processus le noyau maintient une table des fichiers ouverts. Il existe trois "file descriptor" réservés au système : 
\begin{itemize}
	\item \emph{0} : Entrée Standard
	\item \emph{1} : Sortie Standard
	\item \emph{2} : Sortie d'erreur
\end{itemize}
\paragraph{Les fichiers : }
Les fichiers sont vus comme des séquences de bytes (pas d'enregistrement, les blocs physiques ne sont pas visibles). L'offset du fichier courant "tight" au "file descriptor". Les blocs d'appareils sont vus comme des séquences de blocs (l'entiereté des blocs sont lus/écrits en une fois).
\section{Standard I/O Library}
Interface uniforme permettant d'effectuer des opérations d'I/O (Il s'agit d'une interface efficace pour une programmation de haut niveau, fonctionnant avec les streams et permettant un système de buffer de haut niveau (Attention, les Appels Systèmes coûte très cher)) de manière très simple (un seul fichier à inclure (\#include <stdio.h>)).
\paragraph{Les Streams : }
Similaire au "file descriptor", ils désignent les appareils (Ils existent bien entendus des streams prédéfinis de base (stdin, stdout, stderr), et ils sont alloués dynamiquement(un appel à malloc n'est pas requis, la fonction fopen s'en chargeant pour nous)).
\paragraph{User-level buffering : } la sortie n'est pas synchronisée (afin de pallier à cela on pourrait utiliser le système de "flush" (fflush, setbuf)). De plus les streams peuvant être détruit à l'aide de fclose().
\paragraph{Fonctions d'entrée}
\begin{itemize}
	\item int fgetc(FILE *stream);
	\item char *fgets(char *s, int size, FILE *stream);
	\item int getc(FILE *stream);
	\item int getchar(void);
	\item char *gets(char *s);
	\item int ungetc(int c, FILE *stream);
	\item scanf(char * format, ptr1, ptr2);
	\item fscanf(FILE * ioptr, char * format, ptr1, ptr2);
	\item sscanf(char * inbuf, char * format, \&arg1, \&arg2);
	\item strtok 
\end{itemize}   
Attention à un eventuel buffer overflow (il faut toujours vérifier la taille de ce que l'on reçoit, gets est d'ailleurs à éviter).
\paragraph{Fonctions de sortie}
\begin{itemize}
	\item int fputc(int c, FILE *stream);
	\item int fputs(const char *s, FILE *stream);
	\item int putc(int c, FILE *stream);
	\item int putchar(int c);
	\item int puts(const char *s);
	\item printf(char * format, arg1, arg2);
	\item fprintf(FILE * ioptr, char * format, arg1, arg2);
	\item sprintf(char * outbuf, char * format, arg1, arg2); 
\end{itemize}
\paragraph{Les bonnes pratiques de programmation : } il vaut mieux utiliser fgets afin de lire les lignes entrées. Il faut vérifier si un input est vide. Il vaut mieux utiliser sscanf afin de décoder les lignes entrées. Il faut utiliser strtok afin de recevoir un token à partir d'un input.
\section{Redirection}
\paragraph{Limite des Ressources} Les ressources peuvent être limitées au niveau du shell (ulimit -aS pour une "soft limit" et ulimit -aH pour une "hard limit").
\paragraph{User kernel ops "mapping" :} pour chaque commande/operation au niveau de l'utilisateur il y en a un équivalent au niveau du noyau.
\paragraph{Implémenter une redirection :} fermer l'entrée/sortie standard ouvrir un fichier d'entrée/sortie (open() renvoie le plus petit "file descriptor" disponible). Il fqut faire attention car certains problèmes peuvent survenir (l'appareil originel pointé par fd=0 est fermé, par la suite fd=0 est remplacé par "in", le fichier originel perdus est le clavier), la solution à cela est d'utiliser int dup(int fd) qui permet une dupplication du "file descriptor".
\paragraph{Mécanismes d'entrées/sorties : } 
\begin{itemize}
	\item \emph{Mécanismes d'entrées/sorties basiques UNIX : } les données sont lues/écrites depuis les fichiers par un processus. Les i/o sont vus commes des séquences de bytes non-structurées.
	\item \emph{Mécanismes d'entrées/sorties mappés en mémoire : } les objets externes sont mappés dans la mémoire virtuelle du processus.
\end{itemize} 
\section{Locks}
creat() et unlink() peuvent être utilisés afin de créer des cadenas (Locks) (while (creat("lockfile", 0) < 0) sleep(); unlink("lockfile")). Il faut faire attention car cela peut générer une erreur (le orphan lockfile). Il faut savoir que de nombreux problèmes apparaissent lorsque de multiples processus accèdent à la même donnée simultanément. (Pour cela on peut protéger les données à l'aide de cadenas, ces cadenas peuvent être implémentés de bien des manières mais ils doivent être atomiques et sont conseillé et non obligatoire).
\section{Processus}
Un processus est un programme en cours d'exécution. (Un programme est donc un objet statique (un exécutable dans le système de fichier), le processus quant à lui est un objet dynamique (il changera durant l'exécution)).
\paragraph{Définition d'un processus : } Un processus est un programme en cours d'exécution. Un processus contient des données en mémoire dont :
\begin{itemize}
	\item \emph{Du texte : } les instructions qui devront être exécutées.
	\item \emph{Des données globales : } initialisées ou non.
	\item \emph{Des données locales : } placées sur la pile.
	\item \emph{Un Heap : } de la mémoire libre pour les appels à la fonction malloc.
	\item \emph{Un environnement d'exécution :} tant pour le programme (statut, ...) que pour le système.
	\item \emph{Des variables d'environements : } Il s'agit de couples de clé-valeur qui peuvent être accédées par le processus tout comme par ses enfants.
\end{itemize}
Il est identifié par un numéro unique dans le système Unix (PID : process identifier). Il est exécuté par un utilisateur (UID : Identifie l'utilisateur exécutant le processus). 
\paragraph{Les variables d'environnement : } Un processus garde ses variables d'environnement et les paramètres de l'utilisateur définissent des variables d'environnement. Il s'agit de couple clé-valeur. On peut y accéder à partir d'un programme utilisateur (getenv()).
\paragraph{Lancer un processus : } La seule manière de créer un processus est de le faire à l'intérieur d'un processus existant et en utilisant l'appel système fork().
\section{Interruptions système}
Un signal électrique est envoyé par un appareil au processeur afin de stopper l'exécution du processus courant et de faire quelque chose de différent. Le gestionnaire d'interruption est sélectionné par le processeur par la lecture du vecteur d'interruption récupéré de l'appareil. L'état d'exécution est sauvegardé avant l'exécution du gestionnaire d'interruptions et restauré par la suite.
\paragraph{Les signaux : } il s'agit d'interruptions software. Les signaux peuvent être envoyés à un processus par un autre processus, par le terminal de controle, par lui-même ou tout simplement par le système. L'action par défaut d'un signal est de terminer le processus  et de produire un fichier "core dump" (dépend du type de signal). Un processus peut décider d'ignorer certains signaux ou d'en attraper certains. Un signal peut être envoyé à un groupe de processus (Mais un signal ne peut être envoyé que par un processus ayant le même uid). Liste des signaux : 
\begin{itemize}
	\item SIGHUP : Hangup/Reload (Terminate)
	\item SIGINT : Keyboard interrupt (Terminate)
	\item SIGILL : Illegal Instruction (Core dumped)
	\item SIGFPE : Arithmetic exception (Core Dumped)
	\item SIGKILL : Kill (Terminate)	
	\item SIGBUS : Bus error (Core Dumped)
	\item SIGSEGV : Segmentation Violation (Core Dumped)
	\item SIGPIPE : Write a pipe (no reader) (Terminate)
	\item SIGALRM : Alarm clock (Terminate)
	\item SIGTERM : Software termination (Terminate)
	\item SIGSTOP : Stop (Suspended)
	\item SIGTSTP : Stop (from keyboard) (Suspended)
	\item SIGCONT : Continue after stop (Discarded)
	\item SIGCHLD : Child status has changed (Discarded)
	\item SIGUSR1 : User defined signal 1 (Terminate)
	\item SIGUSR2 : User defined signal 2 (Terminate) 
\end{itemize}
Les signaux peuvent être générés par le clavier. Les signaux ne sont traités que si le processus est actif, est en attente I/O sur un appareil plutot lent, ou sur un pipe. D'ailleurs si le signal arrive lors d'une attente I/O cette attente d'I/O se termine prématurément.
\section{IPC's}
\paragraph{Introduction : } Il existe différents types de structure IPC (Les files de messages, les sémaphores, les mémoires partagées). Mais ils partagent tous des caractéristiques communes : un identifiant d'IPC ainsi qu'une structure de permission.
\paragraph{Identifiant IPC : } L'identifiant IPC permet d'identifier la structure IPC. IL s'agit d'un entier ne pouvant que s'incrémenter. Il est renvoyé par int msgget(key\_t key, int msgflg); (pour les files de messages), int semget(key\_t key, int nsems, int semflg); (pour les sémaphores) ainsi que int shmget(key\_t key, size\_t size, int shmflg); (pour les mémoires partagées). Les clés permettent d'accepter de nouveaux processus sur de telles structure. Les identifiant IPC sont globaux dans le système UNIX.\\ \\
La clé peut prendre comme valeur : IPC\_CREAT (si la clé est disponible, crée l'objet IPC) ou IPL\_EXCL  (Si la clé est déjà utilisée, génère une erreur). Les structures IPC sont des structures largement répandues et peuvent être utilisées par des processus totalement différents. Le seul soucis est qu'il faut se mettre d'accord au sujet de tels fichiers (Une clé commune au sein d'un fichier d'include, LE serveur pourrait passer la valeur e l'ipc à travers un fichier ou pourrait générer la clé par ftok(const char *pathname, int project\_id) ).
\paragraph{Structure de permission des structure IPC : } Chaque structure IPC possède une structure ipc\_perm qui lui est reliée.  Voici sa composition :
{ uid\_t uid; /* owner’s effective user id */ \newline
gid\_t gid; \newline
 uid\_t cuid; /* creator’s effective used id */ \newline
 gid\_t cgid; \newline
 mode\_t mode; /* access mode */\newline
 ... \newline
 key\_t key; } 
 \newline
 Comme vous pouvez le remarquer, la composition de structure IPC est très similaire à celle représentant les droits d'accès sur les fichiers régulier. Celle ci peut être changée par : msgctl(), shmctl(), srmctl().
\section{Message queue}
Il s'agit d'une liste chaînée de message sauvegardée dans l'espace noyau.La pile est identifiée par a "message queue id". Elle est ouverte ou créée par msgget(). Les messages sont envoyés par msgsend() (Ils sont rajouté à la fin de la pile). Les messages sont lus par msgrcv() (Ils ne sont pas nécessairement lu en FIFO).  Ces piles possède une structure  msqid\_ds. Ils permettent une communication bidirectionelle entre des processus totalement différents. Les messages ont un type et les frontières entre ces derniers sont préservés. Les piles de message sont en dehors du système de fichier et en dehors de l'arborescence de processus).
\section{Semaphores}
Leur but est de permettre la synchronisation des opérations. Il s'agit d'un entier strictement positif sur lequel on peut effectuer des opérations basiques (incrémenter ou décrémenter la valeur de la sémaphore ainsi que bloquer le processus tant que la sémaphore n'atteigne pas une certaine valeur (par exemple : 0)). Elles permettent de contrôler et de protéger l'accès à certaines ressources critiques.
\paragraph{Remarques : } La valeur d'initialisation peut être 'n' > 1 (Tant que 'n' processus peuvent accéder à cette ressource simultanément. Il faut également noter que les sémaphores doivent obligatoirement être atomiques. En Unix, on ne possède pas une sémaphore mais un ensemble de sémaphores, plusieurs opérations sont disponibles et sont atomiques (semget() : permet de récupérer un identifiant pour un ensemble de sémaphores, semctl() : permet d'effectuer des opérations de controle sur un ensemble de sémaphores, semop() : permet d'effectuer des opérations sur un ensemble de sémaphores).
\section{Mémoires Partagées}
Il s'agit d'une manière d'échanger des données entre les processus, elle est plus rapide que les manières conventionnelles car elle ne nécessite pas d'appels systèmes. Par contre elle nécessite d'être créée par une processus, les autre processus devront donc s'y attacher et dès qu'un processus cesse l'utiliser il devra se détacher.
\section{Appels Systèmes}
\subsection{\href{http://jp.barralis.com/linux-man/man2/open.2.php}{Open()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <stat.h>
	\item \#include <fcntl.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int open(const char \* path, int flags, mode\_t mode);
	\item int open(const char \* path, int flags);
\end{itemize}
\paragraph{Remarques : }
Ouvre les fichiers en écriture ou en lecture. Retourne soit le "file descriptor" soit -1 (en cas d'erreur). Le chemin, "Path", est une chaîne de cractères désignant la ressource dans le système de fichiers. Pour l'argument flags celui-ci peut prendre les valeurs de :
\begin{itemize}
	\item O\_RDONLY : ouvrir en lecture seulement.
	\item O\_WRONLY : ouvrir en écriture seulement.
	\item O\_RDWR : ouvrir en lecture et en écriture.
	\item O\_CREAT : crée le fichier si il n'existe pas.
	\item O\_APPEND : Place le pointeur sur EOF (permet d'écrire à la suite du contenu du fichier).
	\item O\_TRUNC : Si le fichier existe, le remplace.
	\item O\_EXCL : Crée le fichier d'erreur si il y en a.
\end{itemize}
Le mode est un argument utilisé avec O\_CREAT (Il s'agit du mode de fichier Unix). Les erreur quant à elles peuvent être spécifiées par errno.
\subsection{Creat()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <stat.h>
	\item \#include <fcntl.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int creat(const char \* path, mode\_t mode); Pour les fichiers
	\item int mkdir(const char \* path, mode\_t mode); Pour les dossiers
	\item int mknod(const char \* path, mode\_t mode, dev\_t dev); Pour les fichiers spéciaux
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/read.2.php}{Read()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item ssize\_t read(int fd, void \* buf, size\_t len);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{fd : } "file descriptor" du fichier dans lequel il faut lire. (Il peut s'agir d'un fichier "standard" tout comme un substitut d'un pipe ou d'un network socket).
	\item \emph{buf : } adresse du pointeur pour lequel l'input doit être copié.
	\item \emph{len : } Nombre maximum de bytes à lire.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } le nombre de bytes effectivement lus.
	\item \emph{0 : } La fin de fichier est atteinte.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Le retour peut (et est souvent) plus petit que la longueur attendue. Il faut donc être préparé à lire moins de données que ce qui était attendu. 
\subsection{\href{http://jp.barralis.com/linux-man/man2/write.2.php}{Write()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item ssize\_t write(int fd, void \* buf, size\_t len);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{fd : } "file descriptor" du fichier dans lequel il faut écrire. (Il peut s'agir d'un fichier "standard" tout comme un substitut d'un pipe ou d'un network socket).
	\item \emph{buf : } adresse du pointeur pour lequel l'output doit être écrit.
	\item \emph{len : } Nombre maximum de bytes à écrire.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } le nombre de bytes effectivement lus.
	\item \emph{0 : } La fin de fichier est atteinte.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Le retour peut (et est souvent) plus petit que la longueur attendue. Il faut donc être préparé à lire moins de données que ce qui était attendu. 
\subsection{\href{http://jp.barralis.com/linux-man/man2/lseek.2.php}{Lseek()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item off\_t lseek(int fd, int offset, off\_t whence);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{fd : } "file descriptor" du fichier ouvert. (Il peut s'agir d'un fichier "standard" tout comme un substitut d'un pipe ou d'un network socket).
	\item \emph{offset : } Nombre de bytes qui doivent être déplacés (évités) par le pointeur.
	\item \emph{whence : } point de départ (SEEK\_SET : début du fichier, SEEK\_CUR : à partir de la position courante, SEEK\_END à partir de la fin du fichier).
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/ioctl.2.php}{Ioctl()}}
Pour toutes les autres opérations I/O.
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/mtio.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int ioctl(int fd, MTIOCTOP, (struct mtop \*) mt\_cmd);
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/close.2.php}{Close()}}
Permet de dissocier l'entier du descripteur de fichier. Il retourne 0 (en cas de succès) ou -1 (en cas d'erreur). Il faut savoir que tous les fichiers sont fermés lors de la fermeture du programme.
\subsection{\href{http://jp.barralis.com/linux-man/man2/dup.2.php}{Dup()}}
\paragraph{Remarques : } int fd2 = dup(int fd1), fd2 est une dupplication de fd1. fd2 partage le même fichier d'entrée que fd1 (Par cela on entend que fd1 et fd2 partage les même drapeaux statut, le même mode d'accès tout comme le même offset du fichier courant). fd2 sera le plus petit "file descriptor" disponible. fd1 pourra être fermé, par contre l'appel à dup peut échouer (errno : EBADF, EMFILE).
\subsection{Dup2()}
Dup2() est une opération atomique permettant de regrouper close(fd2) ainsi que fd2 = dup(fd1).
\subsection{\href{http://jp.barralis.com/linux-man/man2/mmap.2.php}{Mmap()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <sys/mman.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item caddr\_t mmap(caddr\_t addr, size\_t len, int prot, int fd, int off);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{addr : } devrait être 0.
	\item \emph{len : } Nombre de bytes à mettre en mémoire.
	\item \emph{prot : } Type d'accès(Peut être soit : PROT\_READ, PROT\_WRITE, PROT\_EXEC, PROT\_NONE).
	\item \emph{fd : } "File descriptor" à mettre en mémoire.
	\item \emph{off : } Origine de la map dans fd.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } Retourne le pointeur de base permettant d'accéder aux données.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Le fichier doit être ouvert, plusieurs processus peuvent mettre en mémoire le même fichier, mmap est utilisé par UNIX afin de partager les librairies.
\subsection{Munmap()}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <sys/mman.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int munmap(caddr\_t addr, size\_t len);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{addr : } l'origine de la zone mémoire à enlever de la mémoire.
	\item \emph{len : } Nombre de bytes à enlever de la mémoire.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Détruit la mise en mémoire entre un fichier et l'espace adressé en mémoire virtuelle. Pour fermer un fichier, n'appeler surtout pas munmap. 
\subsection{\href{http://jp.barralis.com/linux-man/man2/msync.2.php}{Msync()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <sys/mman.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int msync(caddr\_t addr, size\_t len, int flags);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{addr : } l'origine de la zone mémoire à enlever de la mémoire.
	\item \emph{len : } Nombre de bytes à enlever de la mémoire.
	\item \emph{flags : } MS\_ASYNC (retourne immédiatement), MS\_INVALIDATE (permet d'invalider le "catching").
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Force le système à écrire les données mappées sur le disque.
\subsection{\href{http://jp.barralis.com/linux-man/man2/link.2.php}{Link()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int link(const char \* name1, const char \* name2);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{name2 : } devient un autre nom pour l'objet déjà existant (name1). (Il s'agit donc juste d'un raccourci).
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Name1 et Name2 auront donc la même inode. (Il n'y a donc aucun moyen de savoir lequel des deux est le nom originel).
\subsection{\href{http://jp.barralis.com/linux-man/man2/unlink.2.php}{Unlink()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int unlink(const char \* name);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{name : } sera supprimer du répertoire courant (si il s'agit de la dernière référence de l'objet, celui-ci sera également supprimé).
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
La permision en écriture est nécéssaire sur le répertoire parent. 
\subsection{\href{http://jp.barralis.com/linux-man/man2/symlink.2.php}{Symlink()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int symlink(const char \* name1, const char \* name2);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{name2 : } sera un lien symbolique de l'objet référencé par name1.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Similaire au lien physiques sans les limitations des frontières du sytème de fichier.
\subsection{\href{http://jp.barralis.com/linux-man/man2/readlink.2.php}{Readlink()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int readlink(const char \* path, void \* buf, size\_t bufsize);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{buf : } où mettre le résultat.
	\item \emph{bufsize : } la taille du buffer.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } la longueur utilisée du buffer. 
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Lit la valeur d'un lien symbolique.
\subsection{\href{http://jp.barralis.com/linux-man/man2/stat.2.php}{Stat()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
	\item \#include <sys/stat.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int stat(const char \* path, struct stat \* buf); retourne des informations au sujet d'un fichier.
	\item int lstat(const char \* path, struct stat \* buf); retourne des informations au sujet du lien symbolique lui même.
	\item int fstat(int fd, struct stat \* buf); => retourne des informations au sujet de l'objet pointé par le lien symbolique. 
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{buf : } pointeur vers une structure de type stat.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } les informations au sujet de l'objet spécifié. 
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/rename.2.php}{Rename()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <stdio.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int rename(const char \* old, const char \* new);
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } la longueur utilisée du buffer. 
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Permet de remplacer l'ancien nom de fichier par le nouveau.
\subsection{\href{http://jp.barralis.com/linux-man/man2/flock.2.php}{flock()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/files.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int flock(int fd, int operation);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{operation : } peut prendre les valeurs : (LOCK\_SH qui signifie cadenas partagé (peut être utilisé par plus d'un processus), LOCK\_EX qui signifie cadenas exclusif (peut être utilisé par un seul processus), LOCK\_NB qui signifie que l'on ne doit pas bloqué lorsque le cadenas est pris (retournera -1 dans le cas où les fichier est bloqué) et LOCK\_UN qui permet de délocker une ressource. 
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man3/lockf.3.php}{Lockf()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int lockf(int fd, int cmd, off\_t len);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{fd : } "file descriptor".
	\item \emph{cmd : } peut prendre les valeurs : F\_LOCK (permet de placer le cadenas), F\_TLOCK (permet de placer le cadenas et de retourner 0 ou -1), F\_ULOCK (permet de nettoyer le cadenas, de le remettre à zéro) et F\_TEST (permet de tester le cadenas).
	\item \emph{len :} longueur de la zone à placer sous cadenas.
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/fork.2.php}{Fork()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
    \item \#include <unsistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item pid\_t fork(void);
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } le pid du fils dans le processus père.
	\item \emph{0 : } au sein du fils.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Les deux processus ont les mêmes copies des données mémoires.De ce fait, ils partagent le même code, les même valeurs de variables, les mêmes fichiers ouverts, les mêmes pointeurs et les mêmes "file descriptor", le même répertoire de travail ainsi que le même terminal de controle. Mais ils ne partagent pas leur compteur de temps d'exécution, les valeurs des sémaphores, les cadenas sur les fichiers, ainsi que les signaux d'alarmes.
\paragraph{Cas spéciaux du fork : }
\begin{itemize}
\item \emph{Le processus parent termine avant le processus enfant :} l'enfant est dès lors attaché au processus init.
\item \emph{L'enfant termine avant le parent :} l'enfant devient dès lors un processus zombie (Il faut savoir qu'un processus enfant terminé continue d'exister tant que le parent ne se termine pas ou que le parent ne vérifie pas la valeur d'exit du processus enfant (wait(), ..)). Un processus zombie ne consume aucune ressource (à part peut être une entrée dans la table des processus).
\item \emph{Synchronisation :} Un processus parent doit parfois attendre que l'un de ses fils se termine. (Utilisation des appels systèmes wait() et exit()).
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/wait.2.php}{Wait()}}
Attend que l'un de ses fils se termine.
\paragraph{Include : }
\begin{itemize}
	\item \#include <sys/types.h>
    \item \#include <sys/wait.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item pid\_t wait(int \* status);
    \item pid\_t waitpid(pid\_t pid, int \* status);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{status : } peut contenir des valeurs d'exit (lire le man).
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{ret : } le pid du fils que l'on attendait.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Il peut attendre un fils spécifique et même en attendre plusieurs.
\subsection{\href{http://jp.barralis.com/linux-man/man3/exit.3.php}{Exit()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int exit();
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
L'appel système \_exit(status) : Termine le processus courant immédiatement (les "file descriptor" ouverts sont fermés, les processus enfant sont envoyés à un autre processus (init), le processus parent recoit un signal SIGCHLD, le statut est retourné au processus parent).
La fonction exit(status) : exécute les fonctions de fin de processus (tels que le flushing des streams) et appelle \_exit(status).
Dès lors la fonction exit devrait être privilégiée à l'appel système \_exit().
\subsection{\href{http://jp.barralis.com/linux-man/man3/exec.3.php}{Exec()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int execl(const char \* pahtname, const char \* arg0, ... \/\* (char \*) 0 \*\/ ); le PATHNAME doit être exact.
    \item int execv(const char \* pathname, const char \* argv[]); Le PATHNAME doit être exact. 
    \item int execle(const char \* pathname, const char \* arg0, ... \/\* (char \*) 0, const char \* envp[] \*\/);
    \item int execve(const char \* pathname, const char \* argv[], const char \* envp[]); Il s'aggit du seul appel système.
    \item int execlp(const char \* filename, const char \* arg0, \/\* (char \*) 0 \*\/); On recherche le PATHNAME dans PATH.
    \item int execvp(const char \* filename, const char \* argv[]); On recherche le PATHNAME dans PATH.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Remarques : }
Il exécute un processus, il ne le démarre pas (Le processus est déjà lancé par fork()) exec va dépasser le processus courant par un nouveau. Il s'agit d'une famille de fonctions mais d'un appel système. 
\subsection{\href{http://jp.barralis.com/linux-man/man2/pipe.2.php}{Pipe()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int pipe(int filedes[2]);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{filedes[0] : } "file descriptor" ouvert pour lecture.
    \item \emph{filedes[1] : } "file descriptor" ouvert pour écriture.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\paragraph{Errno :}
\begin{itemize}
	\item EMFILE
    \item ENFILE
    \item EFAULT
\end{itemize}
\paragraph{Remarques : }
Plutot inutile au sein d'un seul processus. Il faut le combiner avec fork pour le rendre vraiment efficace. Les données vont dans une direction, les pipes ne peuvent être utilisées que dans des processus ayant au moins un ancêtre commun. (Il faut les paramétrer avant le fork). La synchronisation est possible par : le blocage du reader lorsque le pipe est vide, le blocage du writer lorsque le pipe est plein. Un processus pourrait être à la fois writer et reader. Les processus doivent par contre être d'accord sur la taille et le format des messages échangés. Les "file descriptor" qui ne sont pas utilisés doivent être fermés afin d'empêcher un deadlock d'apparaitre.
\paragraph{popen() : } permet de simplifier le processus d'envoi de données à un autre processus (Il faut inclure <stdio.h> et il se déclare : FILE \* popen(const char \* cmd, const char \* type);). Il s'utilise avec pclose(FILE \* stream). 
\subsection{\href{http://jp.barralis.com/linux-man/man2/kill.2.php}{Kill()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <signal.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item int kill(int pid, int sig);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{pid : } processus de destination ou groupe du processus (pid > 0 le signal est envoyé au processus, pid = 0, le signal est envoyés à tous les processus du groupe de l'appellant, pid = -1 le signal est envoyé à tous les processus (à part init et les processus des autres utilisateurs), pid < -1 : le signal est envoyé à tous les processus du groupe du processus). On peut obtenir le pid à l'aide de fork (valeur de retour), getpid (retourne mon propre pid) ou getppid (retourne le pid du processus parent).
	\item \emph{sig : } le nom du signal ou son nombre (Si sig = 0 aucune action n'est effectuée). 
\end{itemize}
\paragraph{Errno :}
\begin{itemize}
	\item EINVAL : Le numéro de signal est invalide.
    \item ESRCH : Le pid n'existe pas.
    \item EPERM : La permission est refusée.
\end{itemize}
\paragraph{Retour : }
\begin{itemize}
	\item \emph{0 : } en cas de succès.
	\item \emph{-1 : } une erreur est apparue.
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/signal.2.php}{Signal()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <signal.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item sighandler\_t signal(int signum, sighandler\_t handler);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item \emph{signum : } numéro du signal.
	\item \emph{handler : } Peut prendre les valeurs : SIG\_DFL (signal par défaut avec un gestionnaire par défaut), SIG\_IGN (permet d'ignorer le signal) ou tout simplement une valeur spécifiée par l'utilisateur.
\end{itemize}
\paragraph{Remarques : }
Queue : seulement un signal de chaque type peut être enregistré pour un processus (Si il y en a plusieurs, le processus n'en gère qu'un, les autres seront dès lors perdus). 
\begin{itemize}
	\item \emph{SYSV : } Lorsque le signal est traité, les gestionnaires sont remis à défaut.
    \item  \emph{BSD : } ne remet pas le gestionnaire à défaut mais bloque les signaux tant que le gestionnaire n'a pas finis son traitement (pas de défausse, mais mise en queue, ils seront juste remis par la suite). 
\end{itemize}
\paragraph{Vulnérabilité : } une fenêtre e vulnérabilité existe pour cela il faudra utiliser sigaction qui permet d'utiliser un masque durant le traitement du gestionnaire. Il utilisera le comportement BSD et bloquera les autres signaux durant le traitement du gestionnaire.
\subsection{\href{http://jp.barralis.com/linux-man/man2/alarm.2.php}{Alarm()}}
\paragraph{Include : }
\begin{itemize}
	\item \#include <unistd.h>
\end{itemize}
\paragraph{Déclarations : }
\begin{itemize}
	\item unsigned int alarm(unsigned int seconds);
\end{itemize}
\paragraph{Remarques : }
Envoie le signal SIGALRM après quelque secondes.
\subsection{\href{http://jp.barralis.com/linux-man/man2/msgget.2.php}{msgget()}}
\paragraph{Déclarations : }
\begin{itemize}
	\item int qid = msgget(KEY,mode|flags);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
	\item flags peut prendre comme valeur soit : IPC\_CREATE (cela créera la structure si elle n'existait pas déjà et ouvrira la structure si celle ci existait déjà). soit IPC\_EXCL (crée la structure si elle n'existe pas et envoie une erreur ou sinon).   
\end{itemize}
\subsection{msgsnd()}
\paragraph{Déclarations : }
\begin{itemize}
	\item int ret = msgsnd(int qid, const void *ptr, size\_t nbytes, int flag); 
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item qid : il s'agit de l'identifiant de la structure (l'id de la structure qid). 
\item ptr : un pointeur vers une structure contenant un long suivis des données du message.
\item nbytes: la taille de la zone de texte (doit être plus petit que MAX\_LENGTH).
\item flags peut prendre comme valeur IPC\_NOWAIT  
\end{itemize}
\subsection{msgrcv()}
\paragraph{Déclarations : }
\begin{itemize}
	\item int ret = msgrcv(int qid, void *ptr, size\_t nbytes, long type, int flag); 
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item qid : il s'agit de l'identifiant de la structure (l'id de la structure qid). 
\item ptr : un pointeur vers une structure contenant un long suivis des données du message.
\item nbytes: la taille du buffer (doit être égale à BUF\_MAX\_LENGTH). Le message pour sa part est censé être plus petit que BUF\_MAX\_LENGTH.
\item type : le type peut être égal à 0 (le premier message de la file est lu), au dessus de 0 (le premier message étant égal à type est lu) ou peut être en dessous de 0 (le premier message ayant un type plus petit ou égal à la valeur absolue de type est lu).
\item flags peut prendre comme valeur IPC\_NOWAIT (ne bloquera pas si la file est vide) ou MSG\_NOERROR (qui permet de tronquer les messages).
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/msgctl.2.php}{msgctl()}}
\paragraph{Déclarations : }
\begin{itemize}
	\item int msgctl(int qid, int cmd, struct msqid\_ds *ptr)	; 
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item qid : il s'agit de l'identifiant de la structure (l'id de la structure qid). 
\item ptr : un pointeur vers une structure IPC :  msqid\_ds.
\item cmd qui peut prendre comme valeur : IPC\_STAT (retourne la structure de controle), IPC\_SET (qui permet d'écrire : msg\_perm.uid, msg\_perm.gid, msg\_perm.mode et msg\_qbytes à la structure de contrôle) et IPC\_RMID (permet de supprimer la pile de message). 
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/semget.2.php}{semget()}}
\paragraph{Déclarations : }
\begin{itemize}
	\item int semget(key\_t key, int nsems, int semflg);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item key : un nombre représentant une clé.
\item nsems : le nombre de sémaphores de l'ensemble. 
\item semflg :  peut prendre comme valeur soit : IPC\_CREATE (cela créera la structure si elle n'existait pas déjà et ouvrira la structure si celle ci existait déjà). soit IPC\_EXCL (crée la structure si elle n'existe pas et envoie une erreur ou sinon).   
\end{itemize}
\paragraph{Type de retour : } un ensemble de sémaphore (plutôt leur identifiant), il faut par contre faire attention car ces sémaphores sont créés et non initialisées.
\subsection{\href{http://jp.barralis.com/linux-man/man2/semctl.2.php}{semctl()}}
\paragraph{Déclarations : }
\begin{itemize}
	\item int semctl(int semid, int semnum, int cmd, arg); 
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item semid : l'identifiant de l'ensemble de sémaphore.
\item semnum : le numéro de la sémaphore au sein de son ensemble.
\item cmd : Il peut prendre comme valeur :  
\begin{itemize}
	\item GETVAL/SETVAL: permet d'obtenir / de changer la valeur d'une sémaphore.
	\item GETALL/SETALL: permet d'obtenir / de changer la valeur de toutes les sémaphores.
	\item GETPID: permet d'obtenir l'id du dernier processus à avoir utiliser la sémaphore.
	\item GETNCNT: permet d'obtenir le nombre de processus attendant sur la sémaphore (valeur > valeur actuelle).
	\item GETZCNT: permet d'obtenir le nombre de processus attendant sur la sémaphore (valeur = 0).
	\item IPC\_STAT: retourne semid\_ds à l'intérieur d'un pointeur passé à l'aide de arg.
	\item IPC\_SET: modifie le uid et git effectif ainsi que les modes à travers ipc\_perm de  semid\_ds.
	\item IPC\_RMID: supprime l'ensemble de sémaphores.
\end{itemize}
\item arg :  depend de cmd. 
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/semop.2.php}{semop()}}
\paragraph{Déclarations : }
\begin{itemize}
	\item int semop(int semid, struct sembuf sops[], int nsops);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item semid : l'identifiant de l'ensemble de sémaphore.
\item sops : le tableau représentant les sem ops. 
\item nsops: nombre de sem ops. 
\end{itemize}
\paragraph{Sembuf : } sembuf décrit une opération sur une sémaphore.\\
struct sembuf {\\
ushort sem\_num; // numéro de la sémaphore\\
short sem\_op; // Opération sur la sémaphore (+1, -1)\\
short sem\_flg; // flag de la sémaphore \\
}; 
\paragraph{Remarques : } Semop permet d'effectuer des opérations sur un ensemble de sémaphores de manière atomique. 
\paragraph{Opération sur la sémaphore : }
\begin{itemize}
\item sem\_op > 0 : la valeur est ajoutée à la sémaphore courante.
\item sem\_op < 0 : si |sem\_op| <= à la valeur de la sémaphore, |sem\_op| est soustrait de la valeur actuelle de la sémaphore, autrement si |sem\_op| > la valeur de la sémaphore alors semncnt++, le processus courant est endormis jusqu'a ce que |sem\_op| <= la valeur de la semaphore (dès que tel est le cas, soustrait cette valeur à la valeur de la sémaphore).
\item sem\_op == 0 : si la valeur de la sémaphore != 0 : semznct++, le processus attend tant que la valeur de la sémaphore n’égale pas 0 ).
\end{itemize}
\paragraph{Valeur de sem\_flg : } Il peut prendre comme valeur : IPC\_NOWAIT si la condition ferait en sorte que le processus s'endorme : l'appel système se termine directement avec comme code d'erreur : EAGAIN. La deuxième valeur qu'il peut prendre est : SEM\_UNDO (Toute les modifications sur la valeur de la sémaphore du processus courant sont sauvegardées afin d'être effectuées à nouveau à la fin du processus courant. 
\subsection{\href{http://jp.barralis.com/linux-man/man2/shmget.2.php}{shmget()}}
\paragraph{Déclarations : }
\begin{itemize}
	\item int shmget(key\_t key, int size, int shmflg);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item key : un nombre représentant une clé.
\item nsems : taille de la mémoire partagée (LA taille minimum du segment, seulement utile pour le processus créateur de la sharedMemory. 
\item shmflg :  peut prendre comme valeur soit : IPC\_CREATE (cela créera la structure si elle n'existait pas déjà et ouvrira la structure si celle ci existait déjà). soit IPC\_EXCL (crée la structure si elle n'existe pas et envoie une erreur ou sinon).   
\end{itemize}
\subsection{\href{http://jp.barralis.com/linux-man/man2/shmctl.2.php}{shmctl()}}
\paragraph{Déclarations : }
\begin{itemize}
	\item int shmctl(int shmid, int cmd, struct shmid\_ds \*buf);
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item shmid : L'identifiant de la mémoire partagée. 
\item cmd : la commande a exécuté sur shm. 
\begin{itemize}
	\item SHM\_STAT : recupère la structure shmid\_ds depuis le kernel.
    \item SHM\_SET : permet de mettre les champs autorisés de shmid\_ds.
    \item SHM\_RMID : détruit la méoire partagée (Si tous les processus utilisant la mémoire partagée s'en détache alors cela l'a détruit également).
    \item SHM\_LOCK, SHM\_UNLOCK : permettent de bloquer / débloquer la mémoire partagée dans la mémoire physique.
\end{itemize}
\item shmflg : ci requis avec cmd.   
\end{itemize}
\subsection{shmat()}
\paragraph{Déclarations : }
\begin{itemize}
	\item void \*shmat (int shmid, void \*addr, int flag)
\end{itemize}
\paragraph{Explication des paramètres : }
\begin{itemize}
\item shmid : L'identifiant de la mémoire partagée. 
\item addr : devrait être NULL dans les applications actuelles.
\item flag : SHM\_RDONLY.  
\end{itemize}
\paragraph{Retour : } l'adresse mémoire que le processus appelant pourra utiliser.
\paragraph{void shmdt(addr) : } permet de détacher un processus de la mémoire partagée à laquelle il est relié. 
\section{Unix Journey}
Il s'agit d'une partie reprenant plutôt les commandes admins et ce que l'utilisateur utilise.
\subsection{Se déplacer entre les répertoires}
\begin{itemize}
\item cd 
\item cd . (Ne sert à rien (se déplacer jusqu'au répertoire courant revient à ne pas se déplacer du tout). 
\item cd .. : se déplacer vers le répertoire parent. 
\item cd \~ : se déplacer vers le répertoire login
\item cd user : se déplacer au sein du répertoire user présent au sein du répertoire courant.
\end{itemize}
\subsection{Lister les fichiers}
\begin{itemize}
	\item \href{http://jp.barralis.com/linux-man/man1/ls.1.php}{ls} (Il s'agit d'une alias pour /bin/ls
    \item ls -l : En  plus  du  nom, affiche le type du fichier, les permissions d'accès, le nombre de liens  physiques, le  nom  du propriétaire et du groupe, la taille en octets, et l'horodatage (de la  dernière  modification,  sauf  si une autre date est réclamée par les options -c ou -u).
    \item ls -1 : Présente un fichier par ligne.
    \item ls -a : Affiche tous les fichiers des répertoires, y  compris les fichiers commençant par un `.'.
    \item ls -c : Trier  le  contenu  des répertoires en fonction des dates de changement des statuts de fichiers, plutôt qu'en  fonction  de  la date de modification.  S'il
s'agit  d'un  format  long,  afficher  la  date  de changement  de statut plutôt que la date de modification du fichier.
	\item ls -d :  Afficher les répertoires avec la même  présentation que  les  fichiers,  sans  lister leur contenu.  
    \item ls -i : Afficher le  numéro  d'index  (i-noeud)  de  chaque fichier à gauche de son nom.
    \item ls -r :  Inverse le tri du contenu des répertoires.
    \item ls –t : Trie le contenu des répertoires en fonction de la date et non pas en ordre alphabétique. Les fichiers les plus récents sont présentés en premier.
    \item ls –u : Trie  le contenu des répertoires en fonction de la date de dernier accès au fichier plutôt  que  selon la  date  de modification. Si le format d'affichage est large, c'est la date de dernier accès  qui  est affichée.
    \item ls -C : Présente  les  fichiers  en colonnes, triés verticalement.
    \item ls -s : permet de lister la taille des fichiers. 
    \item ls -F : Ajoute un caractère à chaque nom de  fichier  pour indiquer son type.  les fichiers réguliers exécutables sont suivis d'un  `*'.  Les  répertoires  sont suivis  de `/', les liens symboliques d'un `@', les FIFOs  d'un  `|'.   Les  fichiers  réguliers   non-exécutables ne sont suivis d'aucun caractère.
    \item ls - R : Affiche  récursivement  le contenu des sous-répertoires.
	\item ls -s | more –c (note different output - ls use isatty())
	\item ls -S : Trie par taille de fichier.
\end{itemize}
\subsection{Temps des fichiers}
Structure stat :
\begin{itemize}
	\item int stat(const char \*file\_name, struct stat \*buf); : récupère le statut du fichier pointé par file\_name et remplit le buffer buf.
    \item int fstat(int filedes, struct stat \*buf); : est identique à stat, sauf que le fichier ouvert est pointé par le descripteur filedes, obtenu avec open(2).
    \item int fstat(int filedes, struct stat \*buf);  : est identique à stat, sauf que dans le cas d'un lien symbolique, il donne l'état du lien lui-même plutôt que celui du fichier visé.
\end{itemize}
Temps des fichiers :
\begin{itemize}
\item Access time (atime) : Temps depuis la dernière fois que le fichier a été accédé (Read Time).
\item Modified time (mtime) : Temps depuis la dernière fois que le fichier a été modifié (Write Time).
\item Change time (ctime) : Temps depuis la dernière fois que l'inode a été modifié (Inode Change). 
\end{itemize}
\subsection{Déplacer / Copier des fichiers}
\paragraph{\href{http://jp.barralis.com/linux-man/man1/mv.1.php}{mv} : } Permet de déplacer ou de renommer des fichiers. (L'inode peut changer si on change fs).
\paragraph{\href{http://jp.barralis.com/linux-man/man1/cp.1.php}{cp} : } Permet de copier des fichiers. Options disponibles : 
\begin{itemize}
\item -f : Efface les fichiers cibles existants (voir ci-dessus).
\item -i: Interroge l'utilisateur avant d'écraser des fichiers réguliers existants. La question est affichée sur stderr, et la réponse lue depuis stdin.
\item -p Conserve le propriétaire, le groupe, les permissions d'accès et les horodatages du fichier original. Si la conservation du propriétaire ou du groupe est impossible, les bits Set-UID et Set-GID sont effacés. L'horodatage sera quand même légèrement différent entre l'original et la copie car l'opération de copie nécessite un accès en lecture au fichier source.
\item -R : Copie récursivement les répertoires, et gérer correctement les copies des fichiers spéciaux ou des FIFOs.
-r : Copier récursivement les répertoires mais la gestion des fichiers spéciaux n'est pas définie. En fait l'option -r est autorisée, et même encouragée à se comporter comme l'option -R, toutefois le comportement (stupide) de la version GNU n'est pas interdit.
\item -- : Indique la fin explicite de la liste des options.
\end{itemize}
\subsection{Droits d'utilisateur et de groupe}
Fichiers importants : /etc/passwd (information sur les comptes utilisateurs), etc/group (information de groupes), /etc/shadow (information sécurisée sur les comptes utilisateurs), /etc/gshadow.
\paragraph{\href{http://jp.barralis.com/linux-man/man8/useradd.8.php}{useradd} : } Crée un nouvel utilisateur ou mets à jour l'information par défaut sur un nouvel utilisateur.
\paragraph{groupadd : } Crée un nouveau groupe ou mets à jour l'information par défaut sur un nouveau groupe.
\paragraph{\href{http://jp.barralis.com/linux-man/man1/chown.1.php}{chown} : } Modifie le propriétaire et le groupe d'un fichier.
\paragraph{\href{http://jp.barralis.com/linux-man/man1/chgrp.1.php}{chgrp} : }  Change le groupe propriétaire d'un fichier. 
\subsection{Types de fichiers et protection}
\paragraph{Types de fichier : } Répertoires, fichier régulier, lien symbolique, pipes, sockets,(block/ character) devices.
\paragraph{Bits spécifiques : }
\begin{itemize}
\item setuid : spécifique aux exécutables.
\item setgid : spécifique aux répertoires.
\item sticky bit pour les fichiers.
\item sticky bits pour les répertoires.
\end{itemize}
\paragraph{Cas spécifiques : } rwx pour les répertoires.
\subsection{ Espace Disque : }
\paragraph{Espace disque des fichiers : } Les fichiers prennent de la place sur le disque. Afin de connaitre la place que prend un répertoire, on peut utiliser la commande \href{http://jp.barralis.com/linux-man/man1/du.1.php}{du} (Donne les statistiques sur l'utilisation du disque, donne l'espace du répertoire et non l'espace utilisé par un seul utilisateur). Options pouvant être utilisée avec ce dernier :
\begin{itemize}
\item -a : Affiche les statistiques pour tous les fichiers, pas seulement les répertoires.
\item -k : Affiche la taille en ko (kilo-octets, 1024 octets).
\item -s : Affiche seulement le total pour chaque argument.
\item -x: Ignore les répertoires situés sur un système de fichiers différent de celui de l'argument étudié.
\end{itemize}
Remarques : au sujet des liens physiques : ils ne sont comptés qu'une seule fois.
\paragraph{Espace disque utilisé d'une partition : } on utilisera la commande \href{http://jp.barralis.com/linux-man/man1/df.1.php}{df} (Fournit la quantité d'espace occupé des systèmes de fichiers, elle permet de savori quel est l'espace disponible) Options pouvant être utilisée avec ce dernier :
\begin{itemize}
\item -k : Utilise des unités de 1024 octets plutôt que les unités de 512 octets par défaut.
\item -P : Affichage sur six colonnes, précédées de l'en-tête `Filesystem N-blocks Used Available Capacity Mounted on' (avec N=512, ou N=1024 si l'option -k est utilisée).
\item -h : NOT FOUND
\item -H : NOT FOUND
\item -P : NOT FOUND
\item -t : NOT FOUND
\item -- : Fin explicite de la liste des options.
\end{itemize}
\subsection{ Trouver des fichiers}
Afin de trouver des fichiers on utilisera l'appel système \href{http://jp.barralis.com/linux-man/man1/find.1.php}{find}. Ce dernier peut avoir pour option :
\begin{itemize}
\item  -type c Fichier du type c :
\begin{itemize}
\item b : fichier spécial en mode bloc (avec tampon)
\item c : fichier spécial en mode caractère (sans tampon)
\item d : répertoire
\item p : tube nommé (FIFO)
\item f : fichier régulier
\item l : liens symbolique
\item s : socket
\end{itemize}
\item -perm mode : Fichier dont les autorisations d'accès sont fixées exactement au mode indiqué (en notation symbolique ou octale). La notation symbolique utilise le mode 0 comme point de départ.
\item -perm -mode : Fichier ayant au moins toutes les autorisations indiquées dans le mode.
\item -perm +mode : Fichier ayant certaines des autorisations indiquées dans le mode.
\item -mtime n : Fichier dont les données ont été modifiées il y a n*24 heures.
\item -atime n : dernier accès au fichier il y a n*24 heures.
\item -ctime n : dernière modification du statut du fichier il y a n*24 heures.
\item -size n[bckw] : Fichier utilisant n unités d'espace. Les unités sont des blocs de 512 octets par défaut (ou si un suffixe `b' suit le nombre n), des octets si un suffixe `c' suit n, des kilo-octets si un suffixe `k' est utilisé, ou des mots de 2 octets si un `w' suit le nombre n. La taille ne prend pas en compte les blocs indirects, mais elle comptabilise les blocs des fichiers éparpillés pas encore alloués.
\item -name motif : Fichier dont le nom de base (sans les répertoires du chemin d'accès), correspond au motif du shell. Les méta-caractères (`*', `?', et `[]') ne sont jamais mis en correspondance avec un point `.' au début du nom. Pour ignorer un répertoire, ainsi que tous ses sous-répertoires, utiliser l'option -prune ; vous trouverez un exemple dans la description de l'option -path.
\item -path motif : Fichier dont le nom complet correspond au motif fourni. Lors du développement des méta-caractères, `/' et `.' ne sont pas traités différemment des autres caractères, ainsi par exemple : 
find . -path './sr*sc' 
affichera l'élément de répertoire intitulé './src/misc' (s'il en existe un). Pour ignorer une arborescence complète de répertoires, utilisez l'option -prune plutôt que de vérifier chaque fichier de l'arbre. Par exemple, pour ignorer le répertoire `src/emacs' et tous ses sous-répertoires, tout en affichant le nom de tous les autres fichiers, faites quelque chose comme : 
find . -path './src/emacs' -prune -o -print
\item -user utilisateur : fichier appartenant à l'utilisateur indiqué (U-ID numérique éventuellement)
\item -nouser : Fichier dont l'U-ID numérique ne correspond à aucun utilisateur.
\item group nom\_groupe : fichier appartenant au groupe nom\_groupe (éventuellement ID numérique).
\item -nogroup : Fichier dont le G-ID numérique ne correspond à aucun groupe d'utilisateurs.
\end{itemize}
Remarque : Les arguments numériques peuvent être indiqués comme suit : +n (supérieur à n), -n (inférieur à n) et n (égal à n).
Actions pouvant être utilisée sur find : 
\begin{itemize}
\item -exec commande : Exécute la commande ; vrai si le code de retour 0 est renvoyé. Tous les arguments suivants de find sont considérés comme des arguments pour la ligne de commande, jusqu'à ce qu'on rencontre un `;'. La chaîne `{}' est remplacée par le nom du fichier en cours de traitement, et ceci dans toutes ses occurrences, pas seulement aux endroits où elle est isolée, comme c'est le cas avec d'autres versions de find. Ces deux chaînes peuvent avoir besoin d'être protégées du développement de la ligne de commande par le shell, en utilisant le caractère d'échappement (`\') ou une protection par des apostrophes. La commande est exécutée depuis le répertoire de départ.
\item -ls : NOT FOUND
\item -delete : NOT FOUND
\item -execdir : NOT FOUND
\end{itemize}
\subsection{ Comparaison de fichiers}
On peut pour cela utiliser la commande \href{http://jp.barralis.com/linux-man/man1/diff.1.php}{diff} (Trouve les différences entre des fichiers). Options pouvant être utilisées sur ce dernier :
\begin{itemize}
\item -nb (nb est un nombre entier) Afficher nb lignes de contexte. Cette option ne précise pas le format de sortie par elle-même, elle n'a pas d'effet si elle n'est pas combinée avec -c ou -u. Cette option est obsolète. Pour fonctionner correctement, patch nécessite typiquement deux lignes de contexte.
\item -a : Traiter tous les fichiers comme du texte, et les comparer ligne-à-ligne, même s'ils semblent contenir des données binaires.
\item -b : ne pas tenir compte des différences concernant des espaces blancs.
\item -B : Ne pas tenir compte des différences qui concernent des lignes blanches.
\item --brief : Indique seulement si les fichiers diffèrent, pas les différences elles-mêmes.
\item -c : Utiliser le format de sortie contextuel.
\item -C nb
\end{itemize}
\subsection{Fichiers d'archives / de compression}
\paragraph{\href{http://jp.barralis.com/linux-man/man1/tar.1.php}{tar} : } la version GNU de l'utilitaire tar de gestion d'archives.  
\paragraph{compress : } Compresse ou décompresse des fichiers.
\paragraph{\href{http://jp.barralis.com/linux-man/man1/gzip.1.php}{gzip} : } Compacte ou décompacte des fichiers. 
\subsection{Gestion des processus}
\paragraph{Trouver des processus : } Afin de toruver des processus, on va utiliser la commande \href{http://jp.barralis.com/linux-man/result.php#rech}{ps} (Affiche l'état des processus en cours). Celle ci peut avoir comme options : 
\begin{itemize}
\item l: affichage long
\item u : (utilisateur) présente le nom de l'utilisateur et l'heure de lancement.
\item j : (job) présente les Pgid et Sid.
\item s : (signal) présente les signaux bloqués, ignorés et interceptés.
\item v : (vm) affiche des informations sur la mémoire virtuelle.
\item m : (mémoire) affiche des informations sur l'occupation mémoire. À combiner avec l'option p pour obtenir les nombres de pages.
\item f : (forêt) affiche les arbres généalogiques des processus.
\item a : (autres) présente également les processus des autres utilisateurs.
\item x : affiche les processus qui n'ont pas de terminal de contrôle.
\item S : additionne les temps CPU et les fautes de pagination des processus fils.
\item c : (commande) affiche le nom de la commande exécutée.
\item e : (environnement) présente l'environnement à la suite de la ligne de commande exécutée.
\item w : (wide) affichage large. Ne coupe pas les informations pour les limiter à une seule ligne. Pour être exact, chaque `w' autorise une ligne supplémentaire pour chaque processus. Si la ligne supplémentaire n'est pas nécessaire, elle n'est pas utilisée. Il peut y avoir jusqu'à 100 w.
\item h : ne pas afficher d'en-tête.
\item r : ne présenter que les processus en cours d'exécution (running).
\item n : Affichage numérique des champs USER et WCHAN.
\end{itemize}
\paragraph{\href{http://jp.barralis.com/linux-man/man1/nice.1.php}{nice} : } Exécute un programme avec une priorité d'ordonnancement modifiée.  
\paragraph{\href{http://jp.barralis.com/linux-man/man8/lsof.8.php}{lsof} : } liste les fichiers ouverts.
\subsection{Filtres élémentaires}
\paragraph{Commande \href{http://jp.barralis.com/linux-man/man1/grep.1.php}{grep} : } Affiche les lignes correspondant à un motif donné. Elle peut être utilisée avec les options :
\begin{itemize}
\item -num : Les correspondances seront affichées avec num lignes supplémentaires avant et après. Néanmoins, grep n'affichera jamais une ligne plus d'une fois.
\item -A num : Affiche num lignes supplémentaires après la ligne correspondante.
\item -B num : Affiche num lignes supplémentaires avant la ligne correspondante.
\item -C : est équivalent à -2.
\item -V : Affiche le numéro de version de grep sur la sortie d'erreur standard. Ce numéro de version devra être inclus dans tous les rapports de bogues (voir plus bas).
\item -b : Avant chaque ligne, afficher son décalage (en octet) au sein du fichier d'entrée.
\item -c : Ne pas afficher les résultats normaux. À la place, afficher un compte des lignes correspondantes pour chaque fichier d'entrée. Avec l'option -v (voir plus bas), afficher les nombres de lignes ne correspondant pas au motif.
\item -e motif : Utilise le motif indiqué. Ceci permet de protéger les motifs commençant par -.
\item -f fichier : Lit le motif dans le fichier indiqué.
\item -h : Ne pas afficher le nom des fichiers dans les résultats lorsque plusieurs fichiers sont parcourus.
\item -i : Ignore les différences majuscules/minuscules aussi bien dans le motif que dans les fichiers d'entrée.
\item -L : Ne pas afficher les résultats normaux. À la place, indiquer le nom des fichiers pour lesquels aucun résultat n'aurait été affiché.
\item -l : Ne pas afficher les résultats normaux. À la place, indiquer le nom des fichiers pour lesquels des résultats auraient été affiches.
\item -n : Ajoute à chaque ligne de sortie un préfixe contenant son numéro dans le fichier d'entrée.
\item -q : Silence. Ne pas afficher les résultats normaux.
\item -s : Ne pas afficher les messages d'erreurs concernant les fichiers inexistants ou illisibles.
\item -v : Inverser la mise en correspondance, pour sélectionner les lignes ne correspondant pas au motif.
\item -w : Ne sélectionne que les lignes contenant une correspondance formant un mot complet. La sous-chaîne correspondante doit donc être soit au début de la ligne, soit précédée d'un caractère n'appartenant pas à un mot. De même elle doit se trouver soit à la fin de la ligne, soit être suivie par un caractère n'appartenant pas à un mot. Les caractères composants les mots sont les lettres, les chiffres et le souligné (`\_'). ([NDT] Bien entendu les minuscules accentuées ne sont pas des lettres ! Elles servent donc à séparer les mots...)
\item -x : Ne sélectionne que les correspondances qui occupent une ligne entière.
\end{itemize}
\paragraph{\href{http://jp.barralis.com/linux-man/man1/dirname.1.php}{dirname} : } Ne conserve que la partie répertoire d'un chemin d'accès.
\paragraph{\href{http://jp.barralis.com/linux-man/man1/basename.1.php}{basename} : } Élimine le chemin d'accès et le suffixe d'un nom de fichier.
\paragraph{\href{http://jp.barralis.com/linux-man/man1/gawk.1.php}{awk} : } Langage d'examen et de traitement de motifs.  
\paragraph{\href{http://jp.barralis.com/linux-man/man1/tr.1.php}{tr} : } Transpose ou élimine des caractères.
\paragraph{\href{http://jp.barralis.com/linux-man/man1/sort.1.php}{sort} : } Trie les lignes d'un fichier texte.
\paragraph{\href{http://jp.barralis.com/linux-man/man1/head.1.php}{head} -n : }  Affiche le début d'un fichier (-n : nombre de lignes).  
\paragraph{\href{http://jp.barralis.com/linux-man/man1/tail.1.php}{tail} -n : } Affiche la dernière partie d'un fichier (-n : nombre de lignes).
\paragraph{\href{http://jp.barralis.com/linux-man/man1/xargs.1.php}{xargs} : } construire et exécuter des lignes de commandes à partir de l'entrée standard.
\subsection{ Plus de filtres}
\paragraph{Editors : } Discussion au sujet des éditeurs (dd, ex, vi, emacs, nemacs, pico). 
\paragraph{Différences cat et tac : } \href{http://jp.barralis.com/linux-man/man1/cat.1.php}{cat} : Concatène des fichiers et les affiche sur la sortie standard. \href{http://jp.barralis.com/linux-man/man1/tac.1.php}{tac} : Concatène et affiche des fichiers à l'envers.
\subsection{ Shells}
Le shell est l'interpréteur de commandes (Il n'y a pas qu'un seul interpréteur de commandes : sh, csh, ksh, bash, tcsh, zsh, ce qui fait que chaque interpréteur à ses propres particularités, tels que la syntaxe de programmation, ou son historique), il s'agit également du nom générique d'un command file. Le shell par défaut est le dernier champ de /etc/passwd (Les shells valides sont repris dans le fichier : /etc/shells).
\subsection{ Bash Programming}
\paragraph{Utilisation de variables : } Les variables peuvent être locales ou globales. Elles peuvent également être prédéfinies : 
\begin{itemize}
\item \$\$ (pid)
\item \$\*
\item \$?
\item \$0
\item \$\#
\item \$1 \$2 \$3 \$4 ...
\item \$BASH\_VERSION
\end{itemize}
\subsection{ Shell Escaping}
On peut procéder a l’échappement de caractères à l'aide de : 
\begin{itemize}
\item /
\item simple quotes
\item double quotes
\item prargs
\end{itemize}
\section{Liens Externes}
\end{document}
