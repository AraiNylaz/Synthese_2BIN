\documentclass{article}[12pt]

%--------------Packages------------------------------
\usepackage[utf8]{inputenc} %Pour encoder du texte en français
\usepackage[francais]{babel} %Pour encoder du texte en français
\usepackage{graphicx} %pour inclure des images
\usepackage{changepage}
\usepackage{version} % permet d'utiliser l'environnement comment
\graphicspath{{./figures/}} %repertoire images
\usepackage{listings} %si on veut afficher du code, le code doit se trouver dans un dossier "codes" 					  %lui même dans le même répertoire que ce fichier tex
\usepackage{color} %nécessaire pour changer les couleurs du highlighting du code
\usepackage{amsmath,amssymb}%pour des maths au cas où
\usepackage{array,multirow,makecell}%Pour manipuler les tableaux
\usepackage{url} %pour utiliser les liens hypertextes
\usepackage{hyperref} %pour utiliser les liens hypertextes
\usepackage{float}
\newlength{\offsetpage}
\setlength{\offsetpage}{2.0cm}
\newenvironment{widepage}{\begin{adjustwidth}{-\offsetpage}{-\offsetpage}%
    \addtolength{\textwidth}{2\offsetpage}}%
{\end{adjustwidth}}

\newcommand{\JavaScript}[2]{
	\begin{itemize}
		\item[]\lstinputlisting[caption=#2,label=#1]{#1.js}
	\end{itemize}
}
% ---------- Document ------------ %
\begin{document}

\input{page_de_garde.tex}

\tableofcontents%table des matières
\newpage

\section{Présentation du JavaScript}

\subsection{Langage d'avenir}

Le JavaScript est un langage créé pour le front-end Web, il peut également être utilisé au niveau back-end Web notamment à l'aide de Node.js.

\subsection{Mauvaise réputation}

\paragraph{Argument 1} : Performances médiocres

\paragraph{Argument 2} : Le langage est considéré comme sale, ceci est du à certaines {\color{blue}spécificités} du langage parfois inhabituelles. ({\color{blue}Beaucoup de manières de faire la même chose}, et ceci de manière très différentes).

\subsection{Les bons côtés}

Il existe divers moyens afin de réaliser la même opération et de ce fait parmi toutes ces manières, il en existe forcément {\color{blue} une simple à comprendre et à utiliser} 

\subsection{Langage interprété}

Il n'y a pas de phase de compilation, c'est donc le code source qui sera directement utilisé lors de la compilation.

\subsection{Langage dynamiquement typé}

Le type des variables est déterminé à l'exécution, le mot clef {\color{blue} var} sert à déclarer les variables (Attention, le type d'une variable peut changer lors de l'exécution du programme).
\newpage
\subsection{Opérateur instanceOf}

\begin{figure}[H]
	\centering
	\fbox{\includegraphics{instanceOf.PNG}}
    \caption{Tableau montrant le résultat renvoyé par l'opérateur instanceOf}
\end{figure}

\subsection{Opérateur typeOf}

Fonction permettant de tester une variable et de retourner une chaîne de caractères décrivant le type de cette dernière.

\begin{figure}[H]
	\centering
	\fbox{\includegraphics[scale=0.90]{typeOf.PNG}}
    \caption{Tableau montrant le résultat renvoyé par l'opérateur typeOf}
\end{figure}

\subsection{Différence entre "==" et "==="}

"==" effectue un transtypage faiblement typé. Ceci peut parfois donner des résultats surprenant, on évitera donc de l'utiliser. équivalent de "==" pour démontrer une inégalité : "!="
\newline
\newline
"===" n'effectue pas de transtypage, on le privilégiera donc à "==",  équivalent de "===" pour démontrer une inégalité : "!==".

\subsection{Les fonctions}

Une fonction est considéré comme une méthode sans classe, par ailleurs les fonctions peuvent très bien être assignées au sein de variables. 
\newline
\newline
Étant donné qu'une fonction peut etre affectée à des variables de noms différents, le nom de la fonction n'a pas réellement d'importance. Dans certains cas on ne nommera même pas la fonction (elle sera donc considérée comme une fonction anonyme)
\newline
\newline
C'est la présence ou l'absence de parenthèses qui détermine si on parle de la référence de la fonction, ou de son exécution.

\subsection{Portée lexicale des variables}

Une variable ne se restreint pas au bloc où elle est déclarée, elle se restreint plutôt à la fonction qui  l'englobe.
\newline
\newline
Il faut faire attention aux variables globales car si celles sont utilisées pour définir une autre variable ce sera la référence de la variable globale qui sera retenue au sein de celle-ci et non sa valeur.

\subsection{OO en JavaScript}

JavaScript supporte aussi la programmation orientée objet, mais la manière dont elle fonctionne est fortement différente du java.
\newline
\newline
Les Objets JavaScript indépendamment de la programmation OO fonctionne comme des Maps. On associe une clé à une valeur, on parle alors d'objets associatifs.

\subsection{Gestion des attributs}

\JavaScript{attribute_value}{Valeur d'un attribut}
\JavaScript{change_value}{Modification d'un attribut}
\JavaScript{delete_value}{Suppresion d'un attribut}

\subsection{Objets et héritages}

Les attributs d'un objet peuvent provenir d'un parent de l'objet, par contre la méthode Object.keys ne renverra pas les attributs parents, si l'on désire tout de même y accéder on peut toujours utiliser un for(... in ...). On peut également savoir si un objet possède un attribut a l'aide de la méthode hasOwnProperty("attribut").

\subsection{Pseudo Classe}

\JavaScript{decla_pseudo_classe}{Exemple de déclaration d'une pseudo classe}

\JavaScript{util_pseudo_classe}{Exemple d'utilisation d'une pseudo classe}

\JavaScript{heritage}{Exemple d'utilisation de l'héritage sur une pseudo classe}

\section{JavaScript dans le browser}

\subsection{Ajout du JavaScript au sein de notre page HTML}

\JavaScript{ajoutJS_direct}{Directement au sein de la page HTML}

\JavaScript{ajoutJS_indirect}{Au sein d'un fichier séparé du reste de la page HTML}

\subsection{Méthodes / Variables utiles}

\begin{itemize}
	\item console.log : affiche au sein de la console ce qui lui est passé en paramètre (si variable affiche son contenu).
    \item navigator : objet contenant de l'information sur le browser lui-même, permet de l'identifier.
    \item window : objet manipulant la fenêtre du browser.
    \item document : objet manipulant la fenêtre du browser (document.writeln("argument") remplace le contenu de la pge HTML par celui passé en paramètre).
    \item location : objet représentant l'URL de la page.
    (location.href = cette URL, location.reload() recharge la page, location.replace("URL") navigue vers l'url passée en paramètre).
\end{itemize}
\newpage
\subsection{Document Object Model (DOM)}

\subsubsection{Présentation générale du DOM}

Le navigateur crée de lui même une représentation objet de la page. Lorsque cet objet est manipulé par JavaScript, ce dernier se mets automatiquement à jour.
\newline
\newline
Le DOM a une structure en arbre où chaque nœud représente un élément HTML, par ailleurs certains attributs correspondent aux attributs HTML. Certaines fonctions permettent de manipuler de diverses manières le nœud et/ou d'accéder 	aux autres nœuds.
\newline
\newline
En pratique, traverser un arbre pour trouver un nœud en particulier est très peu souple  (Si on change la moindre chose dans notre structure HTML on devra modifier l'intégralité de notre code en conséquence. Il existe donc des raccourcis facilitant l'accès à des nœuds en particulier.
\begin{figure}[H]
	\centering
    \fbox{\includegraphics{dom.PNG}}
    \caption{Exemple de représentation du DOM d'une page HTML}
\end{figure}

\subsubsection{Quelques méthodes utiles du DOM}
\begin{itemize}
	\item \emph{document.getElementById(...)} : retourne l'objet portant l'id entré en paramètre
    \item \emph{document.getElementsByName(...) } : retourne les objets ayant l'attribut name égal à celui passé en paramètre. (Cette méthode renvoie donc un tableau d'éléments).
    \item \emph{document.getElementsByClassName(...)} : retourne les objets ayant une classe css égale à celle passée en paramètre de la méthode).
    \item \emph{document.getElementsByTagName(...)} : retourne les objets dont le tag HTML est équivalent à celui entré en paramètre.
\end{itemize}

\subsection{Les événements}

Les événements 	permettent de pouvoir réagir aux actions de l'utilisateur, on enregistre alors les fonctions qui seront appelées lors d'actions spécifiques de l'utilisateur (action utilisateur = un événement sur un élément du DOM).
\newline
\newline
Les éléments HTML possèdent des attributs affectables à une fonction JavaScript.
\begin{figure}[H]
	\centering
    \fbox{\includegraphics[scale=0.90]{event_souris.PNG}}
    \caption{Pour exemple voici les événements rattachés à la souris}
\end{figure}
 Par contre, la valeur de l'attribut est unique, si on change cette valeur, la fonction précédemment affectée à cet événement ne sera plus appelée. L'HTML peut quant à lui référencé une fonction JavaScript qui n'est pas encore chargée, Ceci peut conduire a certains disfonctionnements si l'utilisateur réagit trop vite. (Afin de se prévenir de ces problèmes, on enregistre via le DOM, \emph{document.body.addEventListener("click", function(){}})).
\newline
\newline
Les navigateurs ne permettent d'effectuer qu'une seule tâche à la fois (on dit qu'ils sont monothreadés). Ainsi, quand le JS s'exécute, rien d'autre ne s'exécute (pas de chargement de page, pas de rafraîchissement de la page, pas d'autres JS, pas d'interactions avec l'utilisateur, ...).
\newline
\newline
Cas spécial, la fonction : \emph{setTimeout(f,t)}, utilisée si l'on souhaite effectuer des actions dans le futur, .., f sera une fonction appelée après t millisecondes. (Il existe une alternative si l'on désire créer un intervalle : \emph{setInterval(f,t)}

\section{JQuery}

\subsection{Pourquoi le JQuery}

La manipulation du DOM en JavaScript est lourde et donc vite pénible, Elle pose également des problèmes de compatibilité entre les différents navigateurs. à l'aide de JQuery, on va simplifier et normaliser tout cela.
\newline
\newline
Le JQuery permet notamment une bibliothèque JavaScript, d'assurer une compatibilité multi-navigateurs, de simplifier l'écriture de scripts, de demander au serveur de mettre à jour une partie de la page en utilisant une requête AJAX. Le JQuery est notamment utiliser par de nombreux acteurs du premier plan du Web.
\newline
\newline
Attention, il faut toujours attendre que le DOM soit entièrement obtenus avant d'appliquer du code sur notre page. \begin{lstlisting}
$(function(){
	//ici le dom est entierement defini
});
\end{lstlisting}. Une méthode s'utilisera souvent comme suit : selecteur.méthode(paramètres).

\subsection{Méthodes d'écritures}
\begin{itemize}
	\item \emph{selecteur.html("mon message")} : va remplacer le contenu HTML de mon sélecteur et va y écrire mon message à la place.
    \item \emph{selecteur.text("mon message")} : va remplacer la valeur textuelle stockée dans l'élément par le message passé en paramètre.
    \item \emph{selecteur.val("mon message"} : écrit le message dans la zone texte, au contraire si il n'y a pas de paramètres : obtient la valeur entrée dans la zone texte. 
\end{itemize}
Il est intéressant de noter que ces méthodes utilisée sans paramètres renvoie uniquement ce qu'elle représente sans en remplacer le contenu.

\subsection{Sélection d'éléments}
On peut sélectionner les nœuds du DOM qui nous intéressent à l'aide de 
\begin{lstlisting}
	$('Selecteur')
\end{lstlisting} 
où sélecteur représente un sélecteur CSS ou un sélecteur JQuery.Cette fonction, renvoie un objet JQuery qui représente un ou plusieurs éléments du DOM. (C'est une sorte de tableau, on peut notamment utiliser \begin{lstlisting}
	$('element:first')
\end{lstlisting} afin de recevoir la premier élément de la page, toutes les caractéristiques normalement applicables à un tableau le sont également pour celui-ci.
\begin{figure}[H]
	\centering
    \fbox{\includegraphics[scale=0.60]{selecteur1.PNG}}
    \caption{Exemples de sélecteurs d'éléments}
\end{figure}
\begin{figure}[H]
	\centering
    \fbox{\includegraphics[scale=0.60]{selecteur2.PNG}}
    \caption{Suite des exemples de sélecteur d'éléments}
\end{figure}
\subsection{Modifier le css}
\begin{itemize}
	\item \emph{selecteur.css('attribut')} : récupère la valeur d'un attribut css.
    \item \emph{selecteur.css('attribut','valeur')} : définit un attribut css.
    \item \emph{selecteur.css({"attribut1":"valeur1",
    							"attribut2":"valeur2"}} : définit plusieurs attributs CSS.
\end{itemize}
\subsection{Parcourir les éléments sélectionnés}
\begin{lstlisting}
$('Selecteur').each(function(index) {
	// $(this) donne l'element courant
});
\end{lstlisting}
où index est une variable JavaScript qui représente la position de l'élément dans la sélection.
\subsection{Listener}
On peut attacher un listener sur un event à l'aide d'un sélecteur :
\begin{lstlisting}
	$('.a').click(function(){ alert("Click sur une balise de class a!"); });
\end{lstlisting}
On peut utiliser une manière de lier de façon générique : le \emph{on}
\begin{lstlisting}
$('.c').on("mouseenter", function(){
	$('.c').text("Mouse au-dessus");
});
\end{lstlisting}
\subsection{Insertion d'éléments dans le DOM}
\begin{itemize}
	\item \emph{.append()} : ajoute l'élément après ceux déjà présent au sein de celui passé en paramètre.
    \item \emph{.prepend()} : ajoute l'élément avant ceux déjà présent au sein de celui passé en paramètre.
   	\item \emph{.after()} : ajoute l'élément après celui auquel la méthode est attachée.
    \item \emph{.before()} : ajoute l'élément avant celui auquel la méthode est attachée.
\end{itemize}
\subsection{Sélecteurs spécifiques aux formulaires}
\begin{figure}[H]
	\centering
    \fbox{\includegraphics[scale=0.60]{selecteur_formulaire.PNG}}
    \caption{Exemple de sélecteurs de formulaires}
\end{figure}
\paragraph{Quelques remarques} Le contraire de focus est blur, on peut générer des clicks nous mêmes : selecteur.click().
\section{Chapitre 5 : JavaScript Object Notation (JSON)}
\subsection{JSON = variable sérialisable}
Sérialisable car elle peut être transformée en une suite de bytes équivalent. (Les valeurs doivent avoir un type reconnus (booléen, null, objet, ...). Les clefs sont entourées de guillemets (obligatoire en JSON, facultatif en JavaScript). Les valeurs sont des chaînes des caractères, pas des fonctions.
\subsection{Utilité de JSON}
\begin{itemize}
	\item Il s'agit d'un format standardisé.
    \item Il est sérialisable donc il peut être sauvé dans un fichier.
    \item Des librairies sont disponibles dans de nombreux langages.
    \item Il s'agit d'un support natif du JavaScript.
\end{itemize}
\subsection{Support JavaScript pour JSON}
Toute entité JSON est une valeur JavaScript, rétrospectivement, toute valeur JavaScript sérialisable est une entité JSON. \emph{JSON.parse} transforme une chaîne de caractère en l'objet JSON correspondant, dans l'autre sens, \emph{JSON.stringify} va transformer un objet JSON en la chaîne de caractère correspondante.
\begin{figure}[H]
	\centering
    \fbox{\includegraphics{json_example.PNG}}
    \caption{Exemple structure de JSON}
\end{figure}
\section{HTTPServlet}
\subsection{Subdivisions Application Web}
Une application Web est subdivisées en deux parties : le front-end (gestion du navigateur, permet d'émettre des requêtes (Au Format HTTP)) et le back-end (gestion des fichiers et des requêtes).
\newline
\newline
Le passage du front-end au back-end est une question composée de :
\begin{itemize}
	\item Une URL
    \item une méthode
    \item une adresse d'origine
    \item des cookies
    \item des données à envoyer
    \item d'un mymetype pour les données à envoyer
    \item des en-têtes 
\end{itemize}
Le passage du back-end -> front-end est une réponse composée de : 
\begin{itemize}
	\item Un code d'état (200 = OK, ...)
    \item Des données
    \item Un mime-type pour ces données
    \item Des modifications de cookies
    \item Des en-têtes, des informations sur la manière de cacher les entrées
\end{itemize}
\subsection{Les méthodes des requêtes}
\paragraph{GET} : sert à obtenir une ressource (L'URL entrée dans le navigateur effectue un GET sur cette adresse). Elle est bookmarkable, en générale elle peut être mise en cache.
\paragraph{POST} : sert à soumettre une réponse (Soumission d'un formulaire, les données sont envoyées en POST). Elle est non-bookmarkable, en général elle ne peut pas être mise en cache (La réponse à la soumission d'un formulaire dépend de ce formulaire et change donc à chaque fois).
\paragraph{Les autres méthodes}
\emph{DELETE, PUT} : utilisée dans les API Webs, dans le standard REST (il est peu voir pas du tout utilisé à partir du navigateur).
\subsection{Liaison avec le Java}
Il nous faut un serveur pour écouter les requêtes Web et y répondre. Nous utiliserons un composant Java dédié au traitement des requêtes : Le HTTPServlet (s'utilise au sein d'un serveur Web, traite beaucoup de requêtes différentes : donc de multiples HTTPServlet sur un seul serveur).
\subsection{Configuration des HTTPServlet}
Il faut configurer la ou les servlets pour expliquer à java leur comportement (quels ports écouter, quels chemins dans l'URL correspondent à quels servlets, si il y a un fichier "index.html" à afficher en cas d'absence de précision, ...).
\subsection{HTTPServlet}
Cette classe a pour but d'être étendue, chaque requête HTTP servlet appellera la méthode :
\JavaScript{methode_service}{Méthode Service}
\subsection{HttpServletRequest}
Il s'agit de tout ce qui concerne la requête, voici les méthodes que l'on peut appliquer dessus :
\begin{itemize}
	\item \emph{getPathInfo()} : renvoie la partie d'URL supplémentaire à ce qui est configuré pour le servlet.
    \item \emph{getParameter(String)} : obtient un des paramètres de la requête, c'est à dire des données transmises.
    \item \emph{getCookies()} : retourne les cookies.
\end{itemize}
\subsection{HttpServletResponse}
Il s'agit de tout ce qui concerne la réponse, voici les méthodes que l'on peut appliquer dessus :
\begin{itemize}
	\item \emph{setStatus(int)} : définit le statut de la réponse.
    \item \emph{setContentLength(int)} : définit la longueur en byte de la réponse.
    \item \emph{setCharacterEncoding(String)} : définit l'encodage de la réponse.
    \item \emph{setContentType(String)} : définir le mimetype de la réponse
    \item \emph{getOutputStream()} : retourne l'Output Stream permettant d'écrire la réponse.
\end{itemize}
\subsection{Jetty}
En java, sur un unique serveur Web on peut exécuter plusieurs applications distinctes (On appelle cela un 'Application Server', chaque application y est distinguée par son URL, on déploie par ailleurs son application sur un application server).
\subsubsection{Jetty : Nomenclature}
\begin{itemize}
	\item Server : ce qui écoute sur un port TCP.
    \item WebAppContext : ce qui configure le serveur en tant qu'application server.
    \item ServletHolder : retient le nom et la configuration d'une instance de servlet.
    \item HTTPServlet : classe à étendre pour répondre aux requêtes HTTP.
\subsubsection{Principe}
\JavaScript{principe_jetty}{Principe Jetty}
\subsubsection{WebAppContext}
\JavaScript{webappcontext}{Quelques méthodes du WebAppContext}
\end{itemize}
\subsection{Configuration d'une application Web}
\paragraph{web.xml} : Description XML de la configuration de l'application. Sur un Application Server, chaque application possède son propre web.xml la concernant.
\paragraph{Embedded}
A la place d'avoir un application server sur lequel on déploie les applications, on va utiliser un processus Java qui embarque son propre application server pour y déployer son unique application. Même si cela est moins souple qu'un application server, cela est plus pratique lors du développement(Pas de phase de déploiement, c'est une pure application Java qui s'exécute, par ailleurs, les outils de debugging habituels restent fonctionnels).
\subsection{Exception}
\subsubsection{Exceptions dans doGet ou doPost}
Lorsqu'un fichier est non-trouvé : Error 404, Ceci est un traitement normal du coté Java et non une exception jetée.
\JavaScript{error404}{Gestion de l'erreur 404}
\subsubsection{Exception en Java}
Si une exception s'échappe, c'est Jetty lui-même qui la gérera (redirection vers une page d'erreur ou envoi d'un message standard). En général on évitera de laisser s'échapper les exceptions.
\JavaScript{gestion_exception}{Gestion des Exceptions}
\section{Chapitre 7 : Genson}
\subsection{Traitement du JSON en java ? }
En java, il n'y a pas de support natif pour le JSON, par contre plusieurs librairies permettent de le traiter, dont Genson.
\subsection{Présentation du Genson}
On appellera dé sérialisation le passage d'un JSON vers du Java. Au contraire, on appellera sérialisation la transformation d'un objet Java en un objet JSON.
\subsection{instanciation du Genson}
\JavaScript{genson_direct}{Directement}
\JavaScript{genson_builder}{Via un builder pour une configuration plus précise}
\subsection{Genson avec des collections standards}
Liste des transformations : 
\begin{itemize}
	\item \emph{JSON objects} : Une map java ayant des chaînes de caractères pour clés.
    \item \emph{JSON arrays} : Une liste ou un tableau Java.
    \item \emph{JSON numbers} : Un long ou un double Java.
    \item \emph{JSon String} : Une chaîne de caractère Java.
\end{itemize}
LA transformation de Java vers JSON est totalement automatique. La transformation du Java vers le JSON ne l'est par contre pas, il faut préciser vers quelle classe désérialiser (En effet l'information de classe est nécessaire en Java mais n'existe pas en JSON). 
\subsection{MODE Plain Old Java Object (POJO) / JavaBean}
\JavaScript{pojo}{Exemple de POJO}
\paragraph{Java vers JSON}
\JavaScript{java_json}{Transformation Java vers JSON}
\paragraph{JSON vers JAVA}, Il faut préciser la classe cible.
\JavaScript{json_java}{Transformation JSON vers Java}
\paragraph{JavaBean} : un JavaBean est un POJO qui est sérialisable, a un constructeur sans arguments, et permet l'accès à des propriétés utilisant des méthodes getter et setter dont les noms sont déterminés par une convention simple.
\subsection{Untyped Java Structures}
Pendant la sérialisation si il n'y a pas d'informations de typage (type Object), Genson va utiliser le type lors de l'exécution.
\JavaScript{untyped_java}{Exemple de Structure Java Untyped}
\subsection{Classe anonyme}
\JavaScript{classe_anonyme}{Exemple de classe anonyme}
Les classes anonymes permettent de déclarer et d'instancier une classe en même temps, elle permettent d'écrire un code plus concis et elles sont souvent utilisée dans le contexte d'écrire un Listener.
\section{Chapitre 8 : Ajax}
\subsection{Utilité des requêtes Ajax}
Avec des requêtes "normales", la réponse est de l'HTML fournie directement à partir de l'implémentation Java. Il est peu pratique de travailler de la sorte, on finis par écrire de l'HTML long et compliqués dans des Strings en Java.
\subsection{JSP}
Il existe une approcha classique qui permet de gérer cette manière de travailler. Utilisation de fichiers templates, les données à injecter dans le template sont retenues dans un modèle Java, des tags JSP permettent de faire le lien entre le modèle et l'HTML à intégrer et le servlet s'occupe de tout faire fonctionner ensemble.
\JavaScript{exempleJSP}{Exemple JSP}
\paragraph{Critique du JSP} : On mélange du Java dans de l'HTML, cela est difficile à maintenir, et requiert beaucoup de discipline. De plus il s'agit d'une navigation à l'ancienne (l'unité de communication est la page entière,correspond au Web classique, pas aux applications Webs modernes.), donc très verbeux et pas amusant à utiliser. 
\subsection{Appel Ajax}
\begin{figure}[H]
	\centering
    \fbox{\includegraphics[scale=0.75]{design_ajax.PNG}}
    \caption{Design Ajax}
\end{figure}
Un appel Ajax est donc une requête HTTP, mais qui ne navigue pas vers une nouvelle page. étant donné que nos requêtes Ajax communiqueront en JSON, ce dernier n'est pas à destination de l'utilisateur et donc ces requêtes seront envoyées avec la méthode POST.
\JavaScript{requete_ajax}{Exemple de requête Ajax}
Attention car uen requête HTML 	transporte du texte pas du JSON, il faudra donc transformer la chaîne de caractère renvoyée par le serveur en un objet JSON (on utilisera pour cela la méthode JSON.parse). Au contraire si l'on souhaite envoyer un objet JSON au sein d'une requête il faudra le transformer d'abord en chaîne de caractères (on utilisera pour cela : JSON.stringify).
\section{Chapitre 9 : L'authentification}
\subsection{Principe de l'authentification}
L'authentification consiste à identifier un utilisateur.
\begin{figure}[H]
	\centering
    \fbox{\includegraphics[scale=0.75]{cycle_vie.PNG}}
    \caption{Cycle de vie Front-end / Back-end}
\end{figure}
\paragraph{Le problème de l'authentification} résident du fait que les requêtes du front-end dépendent de l'utilisateur authentifié, que le serveur connaît cet utilisateur au moment de son authentification et que les requêtes sont facilement manipulables. Le serveur doit donc trouver un moyen de retenir l'utilisateur une fois qu'il est authentifié pour répondre aux requêtes ultérieures correctement.
\subsection{Session}
L'application Server va retenir une conversation (plusieurs requêtes succesives du même front-end) entre un front-end et un back-end (Attention, une conversation n'est pas une connexion TCP, l'application server fais de son mieux pour ne pas se tromper mais des erreurs peuvent survenir).
\newline
\newline
Lors d'une authentification réussie, la session est remplie avec l'id de l'utilisateur.
\begin{lstlisting}
	req.getSession().setAttribute("id", idUser);
\end{lstlisting}
Ainsi, lors des requêtes ultérieures, le serveur récupère l'id à partir de la session.
\begin{lstlisting}
	Object idUser=req.getSession().getAttribute("id");
if (idUser!=null) {...}
\end{lstlisting}
\paragraph{Inconvénients de la session}
\begin{itemize}
	\item La session utilise de la 	mémoire pour chaque utilisateur
    \item Il peut y avoir de longues périodes d'inactivités du front-end (Deux possibilités : soit les sessions n'expirent jamais mais alors la mémoire n'est pas récupérée et au dans le cas contraire, les sessions expirent mais alors l'utilisateur devra se réauthentifier).
    \item En cas de redémarrage du serveur, toutes les données sont perdues
\end{itemize}
Ces inconvénients sont dû à une seule chose : le serveur possède un état dépendant du front-end.
\newline
\newline
La solution à cela serait un serveur Stateless : Cela serait fonctionnel et la réponse à une requête ne dépendrait que de la requête elle-même et non pas d'un état retenu sur le serveur.
\newline
\newline
Mais une requête est trop facilement modifiable, le serveur ne peut avoir confiance qu'en lui-même (on va dès lors utiliser la cryptographie). 
\subsection{Httpservlet HttpSession}
On peut obtenir une HttpSession depuis la requête HTTP (HttpServletRequest) à l'aide de la méthode \emph{getSession()}, cette instance sera une Map<String, Object> sur lequel on peut obtenir un attribut (\emph{getAttribute()}) et en rajouter un (\emph{setAttribute()})
\subsection{Gestion de l'authentification : Json Web Token (JWT)}
Il s'agit d'une chaîne de caractères qui retient les informations d'authentification de l'utilisateur, elle est signée cryptographiquement par le serveur. De ce fait même, seul le serveur peut générer et valider un JWT valide.
\newline
\newline
\JavaScript{creation_jwt}{Création de la chaîne JWT lors d'une authentification réussie}
Dans ce bout de code, JWTSecret est une chaîne de caractères connue uniquement par le serveur.
\newline
\newline
On peut mettre un id, un nom, une date de péremption, l'IP du front-end, mais on ne peut surtout pas mettre le mot de passe de l'utilisateur. De plus une chaîne JWT ne peut être créé que par le serveur (sur base de son secret caché), de ce fait même sa signature ne peut être validée que par le serveur (toujours sur base de son secret caché), par contre elle est facilement décryptable, le front-end peut en lire le contenu facilement et cela sans même connaître le secret.
\newline
\newline
\paragraph{JWT et cookies}
Le navigateur devra donc fournir la chaîne de caractères à chacune de ses requêtes. Il vaudrait donc mieux le retenir au sein d'un cookie, cela rendrait le processus automatique.
\newline
\newline
Les cookies font partie du protocole HTTP. Elles son,t placées au niveau d'un domaine, ont un nom, un contenu et peuvent avoir une date de péremption. Le front-end et le back-end peuvent ajouter/supprimer/modifier les cookies tant que le domaine est correct. Toutes les requêtes HTTP émises par le front-end contiennent tous les cookies placés sur l'URL de la page.
\JavaScript{creation_cookie}{Création d'un cookie contenant la chaîne JWT}
Lors des requêtes ultérieures, on pourra aller chercher la chaîne JWT dans les cookies.
\JavaScript{get_cookie}{Vérification de la présence du cookie}
L'étape finale sera donc de valider la chaîne JWT avant de récupérer l'utilisateur.
\JavaScript{check_jwt}{Vérification de la chaîne JWT}
\paragraph{Authentification avec JWT}, lorsque l'utilisateur rentre son login/mdp, une requête est envoyé sur une Servlet (c'est là que l'on procèder a à une vérification de son login/mdp, en cas de succès, on créera une chaîne JWT qui contient l'id/login de l'utilisateur et on placera cela dans un cookie en renvoyant un message de succès, si au contraire on est dans le cas d'un échec, on renvoie un message d'erreur). Sur base de message renvoyée par le serveur, le front-end décidera de la marche à suivre.
\newline
\newline
\paragraph{Dès que l'utilisateur est authentifié}, chaque requête contiendra le cookie avec la chaîne JWT (Les servlets vont valider le JWT et vont récupérer l'id / le login de l'utilisateur, et effectueront par la suite leur traitement habituel).
\subsection{Session et JWT}
Valider la signature JWT prend du temps, on va donc le faire une fois par session uniquement. Le processus deviendra donc : Est ce que la session est authentifiée, si oui alors on peut traiter la requête, sinon on prends alors la chaîne JWT et on valide la signature. On retiendra cette authentification dans la session pour la prochaine fois et on peut traiter la demande dans le cas ou celle celle ci ne serait pas validée, on redirige vers la page d'authentification.
\subsection{Chapitre Bonus : L'Orienté Objet en JavaScript}
\JavaScript{oo_js}{Exemple d'orienté objet en JavaScript}
L'utilisation du new crée un this lors de l'exécution de la fonction (this et new sont des mots-clés du langage, l'appel d'une fonction avec un new renvoie un this (le this représentera l'instance), la fonction sert donc de constructeur à cette instance, elle définit les propriétés de ce this notamment les fonctions utilisables.
\JavaScript{prototype}{Exemple de prototype JavaScript}
Ici, john.getage() continue à renvoyer son âge, mais this.age est accessible via john.age également. LE principe du prototype lors de l'accès à une propriété : Si on ne trouve pas la propriété directement sur l'objet, alors JS cherche cette dernière sur le prototype de la fonction pour l'appeler.
\JavaScript{heritage_prototype}{Exemple d'Héritage par prototype}
\section{Lecture optionnelle mais conseillée}
\subsection{Chapitre 1}
\begin{itemize}
	\item \href{http://stackoverflow.com/research/developer-survey-2016}{Enquête sur l'utilisation des différents langages}
    \item \href{http://www.stefankrause.net/wp/?p=144}{Différences d'utilisation entre le Java, le JavaScript ainsi que le C}
    \item \href{http://www.w3schools.com/js/js_datatypes.asp}{Différents types de données en JavaScript}
    \item \href{http://www.w3schools.com/js/js_function_closures.asp}{Les Fonctions de closure}
	\item \href{http://www.w3schools.com/jsref/jsref_push.asp}{Documentation sur la fonction push}
\end{itemize}
\subsection{Chapitre 2}
\begin{itemize}
    \item \href{http://www.w3schools.com/jsref/dom_obj_event.asp}{Documentation sur les évènements surgissant aus sein du DOM}
    \item \href{http://www.w3schools.com/js/js_htmldom_eventlistener.asp}{Documentation sur le EventListener}
\end{itemize}
\subsection{Chapitre 3 et 4}
\begin{itemize}
	\item \href{http://stackoverflow.com/questions/1910794/what-is-the-difference-between-jquery-text-and-html}{Différences entre la fonction text() et html().}
    \item \href{http://api.jquery.com/category/selectors/}{Documentation sur les sélecteurs.}
    \item \href{http://api.jquery.com/each/}{Documentation sur la fonction .each().}
    \item \href{http://api.jquery.com/eq/}{Documentation sur la fonction .eq().}
    \item \href{http://api.jquery.com/val/}{Documentation sur la fonction .val().}
    \item \href{http://www.w3schools.com/jsref/dom_obj_event.asp}{Documentation sur les différents événements du DOM.}
    \item \href{http://api.jquery.com/category/events/}{Documentation sur les événements.}
    \item \href{http://api.jquery.com/unbind/}{Documentation sur la fonction unbind().}
    \item \href{https://api.jquery.com}{Documentation globale JQuery.}
\end{itemize}
\subsection{Chapitre 5}
\begin{itemize}
	\item \href{http://json.org}{Documentation sur le JSON} 
\end{itemize}
\subsection{Chapitre 6}
\begin{itemize}
	\item  \href{https://tools.ietf.org/html/rfc2616}{Documentation protocole HTTP}
    \item \href{http://www.eclipse.org/jetty/}{Documentation Jetty}
    \item \href{https://www.sitepoint.com/web-foundations/mime-types-complete-list/}{Liste complètes des mime-types}
    \item \href{https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html}{Liste des codes de statut}
    \item \href{http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html}{Documentation sur la HttpServletRequest}
    \item \href{http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html}{Documentation sur la HttpServletResponse}
\end{itemize}
\subsection{Chapitre 7}
\begin{itemize}
	\item \href{http://owlike.github.io/genson/}{Documentation Genson}
    \item \href{http://owlike.github.io/genson/Documentation/UserGuide/}{Guide d'utilisateur Genson}
    \href{http://owlike.github.io/genson/Documentation/Javadoc/}{Vue Globale Genson}
\end{itemize}
\subsection{Chapitre 8}
\begin{itemize}
	\item \href{http://api.jquery.com/jquery.ajax/}{Documentation sur les requêtes Ajax} 
\end{itemize}
\subsection{Chapitre 9}
\begin{itemize}
	\item \href{https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSession.html}{Documentation sur la HttpSession}
    \item \href{github.com/auth0/java-jwt}{Github pour l'utilisation des JWT au sein d'un code Java}
    \item \href{http://www.journaldev.com/1956/java-servlet-cookies-example}{Documentation sur l'utilisation des cookies au sein de Java}
\end{itemize}
\subsection{Chapitre Bonus}
\begin{itemize}
 \item \href{http://phrogz.net/js/classes/OOPinJS2.html}{Documentation sur l'orienté objet en JavaScript}
\end{itemize}
\subsection{Documentation supplémentaire}
\begin{itemize}
	\item \href{http://www.w3schools.com/bootstrap/}{Documentation sur Bootstrap}
    \item \href{https://jqueryui.com}{Documentation sur JQuery}
    \item \href{https://www.datatables.net}{Documentation sur les DataTables}
    \item \href{https://select2.github.io/examples.html}{Documentation sur les SELECT2}
    \item \href{http://www.w3schools.com/html/html5_canvas.asp}{Documentation sur les Canvas}
\end{itemize}
\end{document}